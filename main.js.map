{"version":3,"sources":["webpack://test-iterative-solver/./box.ts","webpack://test-iterative-solver/./circle.ts","webpack://test-iterative-solver/./collider.ts","webpack://test-iterative-solver/./contact.ts","webpack://test-iterative-solver/./line.ts","webpack://test-iterative-solver/./math.ts","webpack://test-iterative-solver/./separating-axis.ts","webpack://test-iterative-solver/./solver.ts","webpack://test-iterative-solver/./transform.ts","webpack://test-iterative-solver/./vector.ts","webpack://test-iterative-solver/webpack/bootstrap","webpack://test-iterative-solver/./main.ts"],"names":[],"mappings":"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","file":"main.js","sourcesContent":["import { Circle } from \"./circle\";\r\nimport { Collider } from \"./collider\";\r\nimport { Line } from \"./line\";\r\nimport { SeparatingAxis } from \"./separating-axis\";\r\nimport { Vector } from \"./vector\";\r\n\r\nexport class Box extends Collider {\r\n    constructor(public width: number, public height: number, pos: Vector) {\r\n        super();\r\n        this.xf.pos = pos;\r\n        this.mass = 1;\r\n    }\r\n\r\n    get localPoints(): readonly Vector[] {\r\n        const halfHeight = this.height / 2;\r\n        const halfWidth = this.width / 2;\r\n\r\n        const points: Vector[] = [\r\n            new Vector(-halfWidth, -halfHeight),\r\n            new Vector(halfWidth, -halfHeight),\r\n            new Vector(halfWidth, halfHeight),\r\n            new Vector(-halfWidth, halfHeight)\r\n        ];\r\n        return points;\r\n    }\r\n\r\n    get points(): readonly Vector[] {\r\n        const pos = this.xf.pos;\r\n        const rot = this.xf.rotation;\r\n\r\n        const halfHeight = this.height / 2;\r\n        const halfWidth = this.width / 2;\r\n\r\n        const points: Vector[] = [\r\n            pos.add(new Vector(-halfWidth, -halfHeight)),\r\n            pos.add(new Vector(halfWidth, -halfHeight)),\r\n            pos.add(new Vector(halfWidth, halfHeight)),\r\n            pos.add(new Vector(-halfWidth, halfHeight))\r\n        ].map(p => p.rotate(rot, pos));\r\n\r\n        return points;\r\n    } \r\n\r\n    get inverseMass() {\r\n        return this.static ? 0 : 1 / this.mass;\r\n    }\r\n\r\n    get inertia() {\r\n        // https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n        return (this.mass/12) * (this.width + this.height * this.height);\r\n    }\r\n\r\n    get inverseInertia() {\r\n        return this.static ? 0 : 1 / this.inertia;\r\n    }\r\n\r\n    collide(other: Circle | Line | Box) {\r\n        if (other instanceof Circle) {\r\n            return SeparatingAxis.findCircleBoxContact(other, this);\r\n        }\r\n\r\n        if (other instanceof Box) {\r\n            return SeparatingAxis.findBoxBoxContact(this, other)\r\n        }\r\n\r\n        if (other instanceof Line) {\r\n            null; // TODO line\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * ```\r\n     *   +----- 0 \"top\" -----+\r\n     *   |                   |\r\n     *   | 3 \"left\"          | 1 \"right\"\r\n     *   |                   |\r\n     *   |                   |\r\n     *   +----- 2 \"bottom\"---+\r\n     * ```\r\n     * @param index \r\n     */\r\n    getSide(index: number): [Vector, Vector] {\r\n        const pts = this.points;\r\n        const len = this.points.length;\r\n        return [pts[index], pts[(index + 1) % len]];\r\n    }\r\n\r\n    getLocalSide(index: number): [Vector, Vector] {\r\n        const pts = this.localPoints;\r\n        const len = this.localPoints.length;\r\n        return [pts[index], pts[(index + 1) % len]];\r\n    }\r\n\r\n    /**\r\n     * Find the point on the shape furthest in the direction specified\r\n     */\r\n    getFurthestPoint(direction: Vector): Vector {\r\n        const pts = this.points;\r\n        let furthestPoint = pts[0];\r\n        let maxDistance = -Number.MAX_VALUE;\r\n        for (let i = 0; i < pts.length; i++) {\r\n            const distance = direction.dot(pts[i]);\r\n            if (distance > maxDistance) {\r\n                maxDistance = distance;\r\n                furthestPoint = pts[i];\r\n            }\r\n        }\r\n        return furthestPoint;\r\n    }\r\n\r\n    getFurthestLocalPoint(direction: Vector): Vector {\r\n        const pts = this.localPoints;\r\n        let furthestPoint = pts[0];\r\n        let maxDistance = -Number.MAX_VALUE;\r\n        for (let i = 0; i < pts.length; i++) {\r\n            const distance = direction.dot(pts[i]);\r\n            if (distance > maxDistance) {\r\n                maxDistance = distance;\r\n                furthestPoint = pts[i];\r\n            }\r\n        }\r\n        return furthestPoint;\r\n    }\r\n\r\n    findSide(direction: Vector): [Vector, Vector] {\r\n        let bestSide = this.getSide(0);\r\n        let maxDistance = -Number.MAX_VALUE;\r\n        for (let side = 0; side < 4; side++) {\r\n            let currentSide = this.getSide(side);\r\n            const sideNormal = currentSide[1].sub(currentSide[0]).normal();\r\n            const mostDirection = sideNormal.dot(direction);\r\n            if (mostDirection > maxDistance) {\r\n                bestSide = currentSide;\r\n                maxDistance = mostDirection;\r\n            }\r\n        }\r\n        return bestSide;\r\n    }\r\n\r\n    findLocalSide(direction: Vector): [Vector, Vector] {\r\n        let bestSide = this.getLocalSide(0);\r\n        let maxDistance = -Number.MAX_VALUE;\r\n        for (let side = 0; side < 4; side++) {\r\n            let currentSide = this.getLocalSide(side);\r\n            const sideNormal = currentSide[1].sub(currentSide[0]).normal();\r\n            const mostDirection = sideNormal.dot(direction);\r\n            if (mostDirection > maxDistance) {\r\n                bestSide = currentSide;\r\n                maxDistance = mostDirection;\r\n            }\r\n        }\r\n        return bestSide;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, flags: any) {\r\n\r\n        for (let side = 0; side < 4; side++) {\r\n            let currentSide = this.getSide(side);\r\n            ctx.save();\r\n            ctx.beginPath();\r\n            ctx.strokeStyle = 'green'\r\n            ctx.moveTo(currentSide[0].x, currentSide[0].y);\r\n            ctx.lineTo(currentSide[1].x, currentSide[1].y);\r\n            ctx.closePath();\r\n            ctx.stroke();\r\n            ctx.restore();\r\n        }\r\n        if (flags[\"Debug\"]) {\r\n            ctx.fillStyle = 'yellow';\r\n            ctx.fillText('id: ' + this.id, this.xf.pos.x, this.xf.pos.y);\r\n        }\r\n    }\r\n}","import { Box } from \"./box\";\r\nimport { Collider } from \"./collider\";\r\nimport { Contact } from \"./contact\";\r\nimport { Line } from \"./line\";\r\nimport { SeparatingAxis } from \"./separating-axis\";\r\nimport { Vector } from \"./vector\";\r\n\r\nexport class Circle extends Collider {\r\n    constructor(public radius: number, pos: Vector) {\r\n        super();\r\n        this.xf.pos = pos;\r\n        this.mass = 1;\r\n    }\r\n\r\n    get inverseMass() {\r\n        return this.static ? 0 : 1 / this.mass;\r\n    }\r\n\r\n    get inertia() {\r\n        return (this.mass * this.radius * this.radius) / 2;\r\n    }\r\n\r\n    get inverseInertia() {\r\n        return this.static ? 0 : 1 / this.inertia;\r\n    }\r\n\r\n    /**\r\n     * Returns a contact in the direction from `this` -> `other`\r\n     * @param other \r\n     * @returns \r\n     */\r\n    collide(other: Circle | Line | Box, contact?: Contact): Contact | null {\r\n        if (other instanceof Circle) {\r\n            return SeparatingAxis.findCircleCircleContact(this, other);\r\n        }\r\n\r\n        if (other instanceof Box) {\r\n            return SeparatingAxis.findCircleBoxContact(this, other)\r\n        }\r\n\r\n        if (other instanceof Line) {\r\n            return other.collide(this);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Apply impulse at a point\r\n     * @param point \r\n     * @param impulse \r\n     * @returns \r\n     */\r\n    applyImpulse(point: Vector, impulse: Vector) {\r\n        if (this.static) {\r\n            return;\r\n        }\r\n\r\n        const distanceFromCenter = point.sub(this.xf.pos);\r\n\r\n        this.m.vel = this.m.vel.add(impulse.scale(this.inverseMass));\r\n        this.m.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);\r\n    }\r\n\r\n    /**\r\n     * Find the point on the shape furthest in the direction specified\r\n     */\r\n    getFurthestPoint(direction: Vector): Vector {\r\n        const dir = direction.normalize();\r\n        return this.xf.pos.add(dir.scale(this.radius));\r\n    }\r\n\r\n    getFurthestLocalPoint(direction: Vector): Vector {\r\n        const dir = direction.normalize();\r\n        return dir.scale(this.radius);\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, flags?: any) {\r\n        ctx.beginPath();\r\n        ctx.fillStyle = 'blue';\r\n        ctx.arc(this.xf.pos.x, this.xf.pos.y, this.radius, 0, Math.PI * 2);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n\r\n        if (flags[\"Debug\"]) {\r\n            ctx.fillStyle = 'yellow';\r\n            ctx.fillText('id: ' + this.id, this.xf.pos.x, this.xf.pos.y);\r\n        }\r\n\r\n        ctx.save();\r\n        ctx.translate(this.xf.pos.x, this.xf.pos.y);\r\n        ctx.rotate(this.xf.rotation);\r\n        ctx.beginPath()\r\n        ctx.strokeStyle = 'black';\r\n        ctx.moveTo(0, 0);\r\n        ctx.lineTo(0 + this.radius, 0);\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n}","import { Contact } from \"./contact\";\r\nimport { Motion, Transform } from \"./transform\";\r\nimport { Vector } from \"./vector\";\r\n\r\nexport abstract class Collider {\r\n    private static _ID = 0;\r\n    public id = Collider._ID++;\r\n    public static = false;\r\n    public mass = 1;\r\n    \r\n    public bounciness = 0.1;\r\n    public friction = .99;\r\n    public xf = new Transform();\r\n    public m = new Motion();\r\n\r\n    get inverseMass() {\r\n        return this.static ? 0 : 1 / this.mass;\r\n    }\r\n\r\n    get inertia() {\r\n        return this.mass;\r\n    }\r\n\r\n    get inverseInertia() {\r\n        return this.static ? 0 : 1 / this.inertia;\r\n    }\r\n\r\n    /**\r\n     * Apply impulse at a point\r\n     * @param point \r\n     * @param impulse \r\n     * @returns \r\n     */\r\n    applyImpulse(point: Vector, impulse: Vector) {\r\n        if (this.static) {\r\n            return;\r\n        }\r\n\r\n        const distanceFromCenter = point.sub(this.xf.pos);\r\n\r\n        this.m.vel = this.m.vel.add(impulse.scale(this.inverseMass));\r\n        this.m.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);\r\n    }\r\n\r\n    applyLinearImpulse(impulse: Vector) {\r\n        if (this.static) {\r\n            return;\r\n        }\r\n\r\n        this.m.vel = this.m.vel.add(impulse.scale(this.inverseMass));\r\n    }\r\n\r\n    applyAngularImpulse(point: Vector, impulse: Vector) {\r\n        if (this.static) {\r\n            return;\r\n        }\r\n\r\n        const distanceFromCenter = point.sub(this.xf.pos);\r\n\r\n        this.m.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);\r\n    }\r\n\r\n    abstract collide(collider: Collider, contact?: Contact): Contact | null;\r\n    abstract draw(ctx: CanvasRenderingContext2D, flags: any): void;\r\n}","import { Box } from \"./box\";\r\nimport { Circle } from \"./circle\";\r\nimport { Collider } from \"./collider\";\r\nimport { Line } from \"./line\";\r\nimport { assert } from \"./math\";\r\nimport { ContactInfo, SeparatingAxis } from \"./separating-axis\";\r\nimport { Vector } from \"./vector\";\r\n\r\n/**\r\n * Holds information about contact points, meant to be reused over multiple frames of contact\r\n */\r\nexport class ContactPoint {\r\n\r\n    constructor(public point: Vector, public local: Vector, public contact: Contact) {}\r\n\r\n    public getRelativeVelocity() {\r\n        const bodyA = this.contact.bodyA;\r\n        const bodyB = this.contact.bodyB;\r\n        // Relative velocity in linear terms\r\n        // Angular to linear velocity formula -> omega = velocity/radius so omega x radius = velocity\r\n        const velA = bodyA.m.vel.add(Vector.cross(bodyA.m.angularVelocity, this.aToContact));\r\n        const velB = bodyB.m.vel.add(Vector.cross(bodyB.m.angularVelocity, this.bToContact));\r\n\r\n        return velB.sub(velA);\r\n    }\r\n\r\n    /**\r\n     * Impulse accumulated over time in normal direction\r\n     */\r\n    public normalImpulse: number = 0;\r\n\r\n    /**\r\n     * Impulse accumulated over time in the tangent direction\r\n     */\r\n    public tangentImpulse: number = 0;\r\n\r\n    /**\r\n     * Effective mass seen in the normal direction\r\n     */\r\n    public normalMass: number = 0;\r\n    \r\n    /**\r\n     * Effective mass seen in the tangent direction\r\n     */\r\n    public tangentMass: number = 0;\r\n\r\n    /** \r\n     * Direction from center of mass of bodyA to contact point\r\n     */\r\n    public aToContact: Vector = new Vector(0, 0);\r\n\r\n    /** \r\n     * Direction from center of mass of bodyB to contact point\r\n     */\r\n    public bToContact: Vector = new Vector(0, 0);\r\n}\r\n\r\n/**\r\n * Represents contact between two rigid bodies\r\n * \r\n * Meant to be re-used over multiple frames\r\n */\r\nexport class Contact {\r\n\r\n    /**\r\n     * The unique id between 2 bodies\r\n     */\r\n    public get id() {\r\n        return Contact.GetId(this.bodyA, this.bodyB);\r\n    }\r\n\r\n    /**\r\n     * Get the id of 2 bodies\r\n     * @param bodyA \r\n     * @param bodyB \r\n     * @returns \r\n     */\r\n    public static GetId(bodyA: Collider, bodyB: Collider) {\r\n        if (bodyA.id < bodyB.id) {\r\n            return `${bodyA.id}+${bodyB.id}`;\r\n        } else {\r\n            return `${bodyB.id}+${bodyA.id}`;\r\n        }\r\n    }\r\n\r\n    // TODO move this to contact point?\r\n    /**\r\n     * Returns the separation in this contact (negative)\r\n     * @returns \r\n     */\r\n    public getSeparation(point: Vector) {\r\n        if (this.bodyA instanceof Circle && this.bodyB instanceof Circle) {\r\n            const combinedRadius = this.bodyA.radius + this.bodyB.radius;\r\n            const distance = this.bodyA.xf.pos.distance(this.bodyB.xf.pos);\r\n            const separation = combinedRadius - distance;\r\n            return -separation;\r\n        }\r\n\r\n        if (this.bodyA instanceof Circle && this.bodyB instanceof Line) {\r\n            return this.bodyB.getSeparation(this.bodyA);\r\n        }\r\n\r\n        if (this.bodyA instanceof Line && this.bodyB instanceof Circle) {\r\n            return this.bodyA.getSeparation(this.bodyB);\r\n        }\r\n\r\n        // TODO separation needs to work on local points\r\n        if (this.bodyA instanceof Box && this.bodyB instanceof Box) {\r\n            if (this.info.localSide) {\r\n                let side: [Vector, Vector];\r\n                let worldPoint: Vector;\r\n                if (this.info.collider === this.bodyA) {\r\n                    side = [this.bodyA.xf.apply(this.info.localSide[0]), this.bodyA.xf.apply(this.info.localSide[1])];\r\n                    worldPoint = this.bodyB.xf.apply(point);\r\n                } else {\r\n                    side = [this.bodyB.xf.apply(this.info.localSide[0]), this.bodyB.xf.apply(this.info.localSide[1])];\r\n                    worldPoint = this.bodyA.xf.apply(point);\r\n                }\r\n\r\n                return SeparatingAxis.distanceToPoint(side[0], side[1], worldPoint, true);\r\n            }\r\n        }\r\n\r\n        if (this.bodyA instanceof Box && this.bodyB instanceof Circle ||\r\n            this.bodyB instanceof Box && this.bodyA instanceof Circle) {\r\n            if (this.info.side) {\r\n                return SeparatingAxis.distanceToPoint(this.info.side[0], this.info.side[1], this.bodyA.xf.apply(point), true);\r\n            }\r\n        }\r\n\r\n        return 0\r\n    }\r\n\r\n    public flip(): Contact {\r\n        const temp = this.bodyA;\r\n        this.bodyA = this.bodyB;\r\n        this.bodyB = temp;\r\n        this.normal = this.normal.negate();\r\n        this.tangent = this.normal.perpendicular();\r\n        return this;\r\n    }\r\n\r\n    constructor(\r\n        public bodyA: Collider,\r\n        public bodyB: Collider,\r\n        /**\r\n         * Normals point away from bodyA\r\n         */\r\n        public normal: Vector,\r\n        public tangent: Vector,\r\n        public info: ContactInfo,\r\n        public points: Vector[] = [],\r\n        public locals: Vector[] = []\r\n    ) {}\r\n}","import { Circle } from \"./circle\";\r\nimport { Collider } from \"./collider\";\r\nimport { Contact } from \"./contact\";\r\nimport { assert } from \"./math\";\r\nimport { ContactInfo } from \"./separating-axis\";\r\nimport { Vector } from \"./vector\";\r\n\r\nexport class Line extends Collider {\r\n    static = true;\r\n    constructor(public begin: Vector, public end: Vector) {\r\n        super();\r\n        this.xf.pos = begin.add(end).scale(.5);\r\n    }\r\n\r\n    getSeparation(other: Circle) {\r\n        // center of the circle\r\n        const cc = other.xf.pos;\r\n        // vector in the direction of the edge\r\n        const e = this.end.sub(this.begin);\r\n        // amount of overlap with the circle's center along the edge direction\r\n        const u = e.dot(this.end.sub(cc));\r\n        const v = e.dot(cc.sub(this.begin));\r\n\r\n        const den = e.dot(e);\r\n        const pointOnEdge = this.begin\r\n            .scale(u)\r\n            .add(this.end.scale(v))\r\n            .scale(1 / den);\r\n        const d = cc.sub(pointOnEdge);\r\n\r\n        const dd = d.dot(d);\r\n\r\n        const sep = -Math.abs(other.radius - Math.sqrt(dd));\r\n        \r\n        return sep;\r\n    }\r\n    \r\n    collide(other: Circle | Line, contact?: Contact): Contact | null {\r\n        if (other instanceof Circle) {\r\n\r\n            // center of the circle\r\n            const cc = other.xf.pos;\r\n            // vector in the direction of the edge\r\n            const e = this.end.sub(this.begin);\r\n            \r\n            // amount of overlap with the circle's center along the edge direction\r\n            const u = e.dot(this.end.sub(cc));\r\n            const v = e.dot(cc.sub(this.begin));\r\n            \r\n            // Potential region A collision (circle is on the left side of the edge, before the beginning)\r\n            if (v <= 0) {\r\n                const da = this.begin.sub(cc);\r\n                const dda = da.dot(da); // quick and dirty way of calc'n distance in r^2 terms saves some sqrts\r\n                // save some sqrts\r\n                if (dda > other.radius * other.radius) {\r\n                    return null; // no collision\r\n                }\r\n                // RETURN CONTACT\r\n                let separation = da.normalize().scale(other.radius - Math.sqrt(dda));\r\n                let normal = da.normalize();\r\n                let info: ContactInfo = {\r\n                    collider: other,\r\n                    separation: other.radius - Math.sqrt(dda),\r\n                    axis: normal,\r\n                    point: this.begin\r\n                }\r\n                return new Contact(other, this, normal, normal.perpendicular(), info, [this.begin]);\r\n            }\r\n            \r\n            // Potential region B collision (circle is on the right side of the edge, after the end)\r\n            if (u <= 0) {\r\n                const db = this.end.sub(cc);\r\n                const ddb = db.dot(db);\r\n                if (ddb > other.radius * other.radius) {\r\n                    return null;\r\n                }\r\n                // RETURN CONTACT\r\n                let separation = db.normalize().scale(other.radius - Math.sqrt(ddb));\r\n                let normal = db.normalize();\r\n                let info: ContactInfo = {\r\n                    collider: other,\r\n                    separation: other.radius - Math.sqrt(ddb),\r\n                    axis: normal,\r\n                    point: this.end\r\n                }\r\n                return new Contact(other, this, normal, normal.perpendicular(), info, [this.end]);\r\n            }\r\n\r\n            // Otherwise potential region AB collision (circle is in the middle of the edge between the beginning and end)\r\n            const den = e.dot(e);\r\n            const pointOnEdge = this.begin\r\n                .scale(u)\r\n                .add(this.end.scale(v))\r\n                .scale(1 / den);\r\n            const d = cc.sub(pointOnEdge);\r\n\r\n            const dd = d.dot(d);\r\n            if (dd > other.radius * other.radius) {\r\n                return null; // no collision\r\n            }\r\n\r\n            let n = e.perpendicular();\r\n            // flip correct direction\r\n            if (n.dot(cc.sub(this.begin)) < 0) {\r\n                n.x = -n.x;\r\n                n.y = -n.y;\r\n            }\r\n\r\n            n = n.normalize();\r\n\r\n            const mvt = n.scale(Math.abs(other.radius - Math.sqrt(dd)));\r\n\r\n            let info: ContactInfo = {\r\n                collider: other,\r\n                separation: other.radius - Math.sqrt(dd),\r\n                axis: n,\r\n                point: this.begin\r\n            }\r\n            // RETURN CONTACT\r\n            return new Contact(this, other, n, n.perpendicular(), info, [pointOnEdge]);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, flags: any) {\r\n        ctx.save();\r\n        ctx.beginPath();\r\n        ctx.strokeStyle = 'green'\r\n        ctx.moveTo(this.begin.x, this.begin.y);\r\n        ctx.lineTo(this.end.x, this.end.y);\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n        ctx.restore();\r\n\r\n        if (flags[\"Debug\"]) {\r\n            ctx.fillStyle = 'yellow';\r\n            ctx.fillText('id: ' + this.id, this.xf.pos.x, this.xf.pos.y);\r\n        }\r\n    }\r\n}","export const clamp = (val: number, min: number, max: number) => {\r\n    return Math.max(Math.min(val, max), min);\r\n}\r\n\r\nexport const assert = (shouldBeTrue: boolean, message: string) => {\r\n    if (!shouldBeTrue) {\r\n        throw new Error(message)\r\n    }\r\n}\r\n\r\nexport const shuffle = (list: any[]) => {\r\n  // knuth shuffle\r\n  let currentIndex = list.length;\r\n  let randomIndex = 0;\r\n  let tmp = null;\r\n  while (currentIndex > 0) {\r\n      // Pick a remaining element...\r\n    randomIndex = Math.floor(Math.random() * currentIndex);\r\n    currentIndex--;\r\n\r\n    // And swap it with the current element.\r\n    tmp = list[currentIndex];\r\n    list[currentIndex] = list[randomIndex];\r\n    list[randomIndex] = tmp;\r\n  }\r\n  return list;\r\n}","import { Box } from \"./box\";\r\nimport { Circle } from \"./circle\";\r\nimport { Collider } from \"./collider\";\r\nimport { Contact } from \"./contact\";\r\nimport { Vector } from \"./vector\";\r\n\r\nexport interface ContactInfo {\r\n    /**\r\n     * Collider A\r\n     */\r\n    collider: Collider,\r\n    /**\r\n     * Signed value (negative means overlap, positive no overlap)\r\n     */\r\n    separation: number,\r\n    /**\r\n     * Axis of separation from the collider's perpective\r\n     */\r\n    axis: Vector,\r\n    /**\r\n     * Side of separation (reference) from the collider's perpsective\r\n     */\r\n    side?: [Vector, Vector],\r\n    localSide?: [Vector, Vector],\r\n    \r\n    /**\r\n     * Index of the separation side (reference) from the collider's perspective\r\n     */\r\n    sideId?: number,\r\n\r\n    /**\r\n     * Point on collider B (incident point)\r\n     */\r\n    point: Vector;\r\n    /**\r\n     * Local point on collider B (incident point)\r\n     */\r\n    localPoint?: Vector;\r\n}\r\n\r\nexport class SeparatingAxis {\r\n\r\n    static findBoxBoxSeparation(boxA: Box, boxB: Box): ContactInfo {\r\n        let bestSeparation = -Number.MAX_VALUE;\r\n        let bestSide: [Vector, Vector] | null = null;\r\n        let bestAxis: Vector | null = null;\r\n        let bestSideIndex: number = -1;\r\n        let bestOtherPoint: Vector | null = null;\r\n        for (let i = 0; i < 4; i++){\r\n            const side = boxA.getSide(i);\r\n            const axis = side[1].sub(side[0]).normal();\r\n            const vertB = boxB.getFurthestPoint(axis.negate());\r\n            // Separation on side i's axis\r\n            const vertSeparation = SeparatingAxis.distanceToPoint(side[0], side[1], vertB, true); \r\n            if (vertSeparation > bestSeparation) {\r\n                bestSeparation = vertSeparation;\r\n                bestSide = side;\r\n                bestAxis = axis;\r\n                bestSideIndex = i;\r\n                bestOtherPoint = vertB\r\n            }\r\n        }\r\n\r\n        return {\r\n            collider: boxA,\r\n            separation: bestSeparation,\r\n            axis: bestAxis as Vector,\r\n            side: bestSide as [Vector, Vector],\r\n            localSide: boxA.getLocalSide(bestSideIndex),\r\n            sideId: bestSideIndex,\r\n            point: bestOtherPoint as Vector,\r\n            localPoint: boxB.getFurthestLocalPoint(bestAxis!.negate())\r\n        }\r\n    }\r\n\r\n    static findBoxBoxContact(boxA: Box, boxB: Box): Contact | null {\r\n        const separationA = SeparatingAxis.findBoxBoxSeparation(boxA, boxB);\r\n        // If there is no overlap from boxA's perspective we can end early\r\n        if (separationA.separation > 0) {\r\n            return null;\r\n        } \r\n\r\n        const separationB = SeparatingAxis.findBoxBoxSeparation(boxB, boxA);\r\n        // If there is no overlap from boxB's perspective exit now\r\n        if (separationB.separation > 0) {\r\n            return null;\r\n        }\r\n\r\n        // Separations are both negative, we want to pick the least negative (minimal movement)\r\n        const separation = separationA.separation > separationB.separation ? separationA : separationB;\r\n\r\n        // The incident side is the most opposite from the axes of collision on the other shape\r\n        const other = separation.collider === boxA ? boxB : boxA;\r\n        const incident = other.findSide(separation.axis.negate());\r\n\r\n        // Clip incident side by the perpendicular lines at each end of the reference side\r\n        // https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm\r\n        const reference = separation.side as [Vector, Vector];\r\n        const refDir = reference[1].sub(reference[0]).normalize();\r\n        \r\n        // Find our contact points by clipping the incident by the collision side\r\n        const clipRight = SeparatingAxis._clip(incident[0], incident[1], refDir.negate(), -refDir.dot(reference[0]));\r\n        let clipLeft: [Vector, Vector] | null = null;\r\n        if (clipRight) {\r\n            clipLeft = SeparatingAxis._clip(clipRight[0], clipRight[1], refDir, refDir.dot(reference[1]));\r\n        }\r\n\r\n        if (clipLeft) {\r\n            // We only want clip points below the reference edge, discard the others\r\n            const points = clipLeft.filter(p => {\r\n                return SeparatingAxis._below(reference[0], reference[1], p);\r\n            });\r\n\r\n            let normal = separation.axis;\r\n            let tangent = normal.perpendicular();\r\n            // Point Contact A -> B\r\n            if (boxB.xf.pos.sub(boxA.xf.pos).dot(normal) < 0) {\r\n                normal = normal.negate();\r\n                tangent = normal.perpendicular();\r\n            }\r\n            // Points are clipped from incident which is the other collider\r\n            // Store those as locals\r\n            let localPoints: Vector[] = [];\r\n            if (separation.collider === boxA) {\r\n                localPoints = points.map(p => boxB.xf.inverse(p));\r\n            } else {\r\n                localPoints = points.map(p => boxA.xf.inverse(p));\r\n            }\r\n            return new Contact(boxA, boxB, normal, normal.perpendicular(), separation, points, localPoints);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    static findBoxCircleSeparation(box: Box, circle: Circle): ContactInfo {\r\n        const circleDir = circle.xf.pos.sub(box.xf.pos).normalize();\r\n        const boxDir = box.xf.pos.sub(circle.xf.pos).normalize();\r\n        const circlePoint = circle.xf.pos.add(boxDir.scale(circle.radius));\r\n        \r\n        let bestSeparation = -Number.MAX_VALUE;\r\n        let bestSide: [Vector, Vector] | null = null;\r\n        let bestAxis: Vector | null = null;\r\n        let bestSideIndex: number = -1;\r\n        let bestOtherPoint: Vector | null = null;\r\n\r\n        // Test poly axes against circle point\r\n        for (let i = 0; i < 4; i++){\r\n            const side = box.getSide(i);\r\n            const axis = side[1].sub(side[0]).normal();\r\n            const circlePoint = circle.xf.pos.add(axis.negate().scale(circle.radius));\r\n            // Separation on side i's axis\r\n            const vertSeparation = SeparatingAxis.distanceToPoint(side[0], side[1], circlePoint, true); \r\n            if (vertSeparation > bestSeparation) {\r\n                bestSeparation = vertSeparation;\r\n                bestSide = side;\r\n                bestAxis = axis;\r\n                bestSideIndex = i;\r\n                bestOtherPoint = circlePoint\r\n            }\r\n        }\r\n        // Test the circle -> box axis against each point of the box\r\n        let minCircleSeparation = Number.MAX_VALUE;\r\n        let minCircleSide = 0;\r\n        for (let i = 0; i < 4; i++) {\r\n            // project box points on the circle axis\r\n            \r\n            const projection = circleDir.dot(box.points[i]);\r\n\r\n            const minCircle = circleDir.dot(circle.xf.pos) - circle.radius;\r\n\r\n            const maxCircle = circleDir.dot(circle.xf.pos) + circle.radius;\r\n            const separation = Math.min(minCircle - projection, maxCircle - projection);\r\n\r\n            if (separation < minCircleSeparation) {\r\n                minCircleSeparation = separation;\r\n                minCircleSide = i;\r\n            }\r\n        }\r\n\r\n        if (minCircleSeparation > bestSeparation) {\r\n            let boxPt = box.getFurthestPoint(circleDir);\r\n            bestSeparation = minCircleSeparation;\r\n            bestSide = box.getSide(minCircleSide);\r\n            bestAxis = circle.xf.pos.sub(boxPt).normalize();\r\n            bestSideIndex = minCircleSide;\r\n            bestOtherPoint = box.getFurthestPoint(circleDir);\r\n        }\r\n\r\n        return {\r\n            collider: box,\r\n            separation: bestSeparation,\r\n            axis: bestAxis as Vector,\r\n            side: bestSide as [Vector, Vector],\r\n            sideId: bestSideIndex,\r\n            point: bestOtherPoint as Vector\r\n        }\r\n    }\r\n\r\n    static findCircleBoxContact(circle: Circle, box: Box): Contact | null {\r\n        let separation = SeparatingAxis.findBoxCircleSeparation(box, circle);\r\n        if (separation.separation > 0) {\r\n            return null;\r\n        }\r\n\r\n        // make sure that the minAxis is pointing away from circle\r\n        let boxDir = box.xf.pos.sub(circle.xf.pos);\r\n        let axis = separation.axis;\r\n        axis = axis.dot(boxDir) < 0 ? axis.negate() : axis;\r\n\r\n        const point = circle.getFurthestPoint(axis);\r\n        const normal = axis;\r\n\r\n        return new Contact(\r\n            circle,\r\n            box,\r\n            normal,\r\n            normal.perpendicular(),\r\n            separation,\r\n            [point],\r\n            [circle.xf.inverse(point)]\r\n        );\r\n    }\r\n\r\n    static findCircleCircleContact(circleA: Circle, circleB: Circle): Contact | null {\r\n        \r\n        const combinedRadius = circleB.radius + circleA.radius;\r\n        const distance = circleB.xf.pos.distance(circleA.xf.pos);\r\n        if (distance < combinedRadius) {\r\n            const separation = combinedRadius - distance;\r\n            \r\n            // normal points from A -> B\r\n            const direction = circleB.xf.pos.sub(circleA.xf.pos);\r\n            const normal = direction.normalize();\r\n            const tangent = normal.perpendicular();\r\n            const point = circleA.xf.pos.add(normal.scale(circleA.radius));\r\n            const info: ContactInfo = {\r\n                collider: circleA,\r\n                separation: separation,\r\n                axis: normal,\r\n                point: point\r\n            }\r\n            return new Contact(circleA, circleB, normal, tangent, info, [point]);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n    * Find the perpendicular distance from the line to a point\r\n    * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n    * @param point\r\n    */\r\n   static distanceToPoint(begin: Vector, end: Vector, point: Vector, signed: boolean = false) {\r\n     const x0 = point.x;\r\n     const y0 = point.y;\r\n \r\n     const l = end.distance(begin);\r\n \r\n     const dy = end.y - begin.y;\r\n     const dx = end.x - begin.x;\r\n     const distance = (dy * x0 - dx * y0 + end.x * begin.y - end.y * begin.x) / l;\r\n     return signed ? distance : Math.abs(distance);\r\n   }\r\n\r\n   /**\r\n    *  Clips along a line returning a new line given a direction and a length\r\n    * ```\r\n    *      Clip Dir  +-------->  Clip Size\r\n    *         Begin  *---------|-------------*  End\r\n    *  Clipped line  *---------* \r\n    * ```\r\n    * \r\n    **/\r\n   private static _clip(begin: Vector, end: Vector, clipDir: Vector, size: number): [Vector, Vector] | null {\r\n    let dir = clipDir;\r\n    dir = dir.normalize();\r\n\r\n\r\n    const near = dir.dot(begin) - size;\r\n    const far = dir.dot(end) - size;\r\n\r\n    let results = [];\r\n    if (near <= 0) {\r\n      results.push(begin);\r\n    }\r\n    if (far <= 0) {\r\n      results.push(end);\r\n    }\r\n\r\n    if (near * far < 0) {\r\n      const clipTime = near / (near - far);\r\n      results.push(begin.add(end.sub(begin).scale(clipTime)));\r\n    }\r\n    if (results.length !== 2) {\r\n      return null;\r\n    }\r\n\r\n    return [results[0], results[1]];\r\n  }\r\n\r\n  private static _below(begin: Vector, end: Vector, point: Vector): boolean {\r\n    let above2 = ((end.x - begin.x) * (point.y - begin.y) - \r\n    (end.y - begin.y) * (point.x - begin.x))\r\n    return above2 >= 0;\r\n  }\r\n}","import { Contact, ContactPoint } from \"./contact\";\r\nimport { clamp } from \"./math\";\r\n\r\nexport class Solver {\r\n    constructor(public flags: any) {}\r\n    lastFrameContacts: Map<string, Contact> = new Map();\r\n\r\n    // map contact id to contact points\r\n    idToContactPoints: Map<string, ContactPoint[]> = new Map();\r\n\r\n    getContactPoints(id: string) {\r\n        return this.idToContactPoints.get(id) ?? [];\r\n    }\r\n\r\n    preSolve(contacts: Contact[]) {\r\n        // Keep track of contacts that done\r\n        let finishedContactIds = Array.from(this.idToContactPoints.keys());\r\n        for (let contact of contacts) {\r\n            // Remove all current contacts that are not done\r\n            let index = finishedContactIds.indexOf(contact.id);\r\n            if (index > -1) {\r\n                finishedContactIds.splice(index, 1);\r\n            }\r\n            let contactPoints = this.idToContactPoints.get(contact.id) ?? [];\r\n            \r\n            let pointIndex = 0;\r\n            contactPoints.length = contact.points.length;\r\n\r\n            for (let point of contact.points) {\r\n                const bodyA = contact.bodyA;\r\n                const bodyB = contact.bodyB;\r\n                const normal = contact.normal;\r\n                const tangent = contact.tangent;\r\n\r\n                const aToContact = point.sub(bodyA.xf.pos);\r\n                const bToContact = point.sub(bodyB.xf.pos);\r\n    \r\n                const aToContactNormal = aToContact.cross(normal);\r\n                const bToContactNormal = bToContact.cross(normal);\r\n\r\n                const normalMass = bodyA.inverseMass + bodyB.inverseMass + \r\n                                bodyA.inverseInertia * aToContactNormal * aToContactNormal +\r\n                                bodyB.inverseInertia * bToContactNormal * bToContactNormal;\r\n\r\n                const aToContactTangent = aToContact.cross(tangent);\r\n                const bToContactTangent = bToContact.cross(tangent);\r\n    \r\n                const tangentMass = bodyA.inverseMass + bodyB.inverseMass +\r\n                                bodyA.inverseInertia * aToContactTangent * aToContactTangent +\r\n                                bodyB.inverseInertia * bToContactTangent * bToContactTangent;\r\n\r\n                // Preserve normal/tangent impulse by re-using the contact point if it's close\r\n                if (contactPoints[pointIndex] && contactPoints[pointIndex]?.point?.squareDistance(point) < 4) {\r\n                    contactPoints[pointIndex].point = point;\r\n                    contactPoints[pointIndex].local = contact.locals[pointIndex]\r\n                } else {\r\n                    // new contact if its' not close or doesn't exist\r\n                    contactPoints[pointIndex] = new ContactPoint(point, contact.locals[pointIndex], contact);\r\n                }\r\n\r\n                // Update contact point calculations\r\n                contactPoints[pointIndex].aToContact = aToContact;\r\n                contactPoints[pointIndex].bToContact = bToContact;\r\n                contactPoints[pointIndex].normalMass = normalMass;\r\n                contactPoints[pointIndex].tangentMass = tangentMass;\r\n\r\n                pointIndex++\r\n            }\r\n            this.idToContactPoints.set(contact.id, contactPoints);\r\n        }\r\n\r\n        // Clean up any contacts that did not occur last frame\r\n        for (const id of finishedContactIds) {\r\n            this.idToContactPoints.delete(id);\r\n        }\r\n    }\r\n\r\n    postSolve(contacts: Contact[]) {\r\n        // Store contacts\r\n        this.lastFrameContacts.clear();\r\n        for (const c of contacts) {\r\n            this.lastFrameContacts.set(c.id, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Warm up body's based on previous frame contact points\r\n     * @param contacts \r\n     */\r\n    warmStart(contacts: Contact[]) {\r\n        for (let contact of contacts) {\r\n            let contactPoints = this.idToContactPoints.get(contact.id) ?? [];\r\n            for (let point of contactPoints) {\r\n                const normalImpulse = contact.normal.scale(point.normalImpulse);\r\n                const tangentImpulse = contact.tangent.scale(point.tangentImpulse);\r\n\r\n                const impulse = normalImpulse.add(tangentImpulse);\r\n                contact.bodyA.applyImpulse(point.point, impulse.negate());\r\n                contact.bodyB.applyImpulse(point.point, impulse);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Iteratively solve the position overlap constraint\r\n     * @param contacts \r\n     */\r\n    solvePosition(contacts: Contact[]) {\r\n        for (let contact of contacts) {\r\n            let contactPoints = this.idToContactPoints.get(contact.id) ?? [];\r\n            for (let point of contactPoints) {\r\n                const bodyA = contact.bodyA;\r\n                const bodyB = contact.bodyB;\r\n                const normal = contact.normal;\r\n                const separation = contact.getSeparation(point.local);\r\n\r\n                const steeringConstant = this.flags['Steering Factor']; // 0.2\r\n                const maxCorrection = -5;\r\n                const slop = this.flags['Slop']; // .5;\r\n\r\n                // Clamp to avoid over-correction\r\n                // Remember that we are shooting for 0 overlap in the end\r\n                const steeringForce = clamp(steeringConstant * (separation + slop), maxCorrection, 0);\r\n                const impulse = normal.scale(-steeringForce / point.normalMass);\r\n\r\n                \r\n                // This is a pseudo impulse, meaning we aren't doing a real impulse calculation\r\n                // We adjust position and rotation instead of doing the velocity\r\n                if (!bodyA.static) {\r\n                    bodyA.xf.pos = bodyA.xf.pos.add(impulse.negate().scale(bodyA.inverseMass));\r\n                    bodyA.xf.rotation -= point.aToContact.cross(impulse) * bodyA.inverseInertia;\r\n                }\r\n\r\n                if (!bodyB.static) {\r\n                    bodyB.xf.pos = bodyB.xf.pos.add(impulse.scale(bodyB.inverseMass));\r\n                    bodyB.xf.rotation += point.bToContact.cross(impulse) * bodyB.inverseInertia;\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    solveVelocity(contacts: Contact[]) {\r\n        for (let contact of contacts) {\r\n            const bodyA = contact.bodyA;\r\n            const bodyB = contact.bodyB;\r\n\r\n            const restitution = bodyA.bounciness * bodyB.bounciness;\r\n            const friction = Math.min(bodyA.friction, bodyB.friction);\r\n            let contactPoints = this.idToContactPoints.get(contact.id) ?? [];\r\n\r\n            for (let point of contactPoints) {\r\n                const relativeVelocity = point.getRelativeVelocity();\r\n\r\n                // Negate velocity in tangent direction to simulate friction\r\n                const tangentVelocity = -relativeVelocity.dot(contact.tangent);\r\n                let impulseDelta = tangentVelocity / point.tangentMass;\r\n\r\n                // Clamping based in Erin Catto's GDC 2006 talk\r\n                // Correct clamping https://github.com/erincatto/box2d-lite/blob/master/docs/GDC2006_Catto_Erin_PhysicsTutorial.pdf\r\n                // Accumulated fiction impulse is always between -uMaxFriction < dT < uMaxFriction\r\n                // But deltas can vary\r\n                const maxFriction = friction * point.normalImpulse;\r\n                const newImpulse = clamp(point.tangentImpulse + impulseDelta, -maxFriction, maxFriction);\r\n                impulseDelta = newImpulse - point.tangentImpulse;\r\n                point.tangentImpulse = newImpulse;\r\n\r\n                const impulse = contact.tangent.scale(impulseDelta);\r\n                bodyA.applyImpulse(point.point, impulse.negate());\r\n                bodyB.applyImpulse(point.point, impulse);\r\n            }\r\n\r\n            for (let point of contactPoints) {\r\n                // Need to recalc relative velocity because the previous step could have changed vel\r\n                const relativeVelocity = point.getRelativeVelocity();\r\n\r\n                // Compute impulse in normal direction\r\n                const normalVelocity = relativeVelocity.dot(contact.normal);\r\n                // See https://en.wikipedia.org/wiki/Collision_response\r\n                let impulseDelta = (-(1 + restitution) * normalVelocity) / point.normalMass;\r\n\r\n                // Clamping based in Erin Catto's GDC 2014 talk\r\n                // Accumulated impulse stored in the contact is always positive (dV > 0)\r\n                // But deltas can be negative\r\n                const newImpulse = Math.max(point.normalImpulse + impulseDelta, 0);\r\n                impulseDelta = newImpulse - point.normalImpulse;\r\n                point.normalImpulse = newImpulse;\r\n\r\n                const impulse = contact.normal.scale(impulseDelta);\r\n                bodyA.applyImpulse(point.point, impulse.negate());\r\n                bodyB.applyImpulse(point.point, impulse);\r\n            }\r\n        }\r\n    }\r\n}","import { Vector } from \"./vector\";\r\n\r\nexport class Transform {\r\n    public pos: Vector = new Vector(0, 0);\r\n    public rotation: number = 0;\r\n    apply(vec: Vector) {\r\n        return vec.rotate(this.rotation).add(this.pos);\r\n    }\r\n    inverse(vec: Vector) {\r\n        return vec.sub(this.pos).rotate(-this.rotation);\r\n    }\r\n}\r\n\r\nexport class Motion {\r\n    public vel: Vector = new Vector(0, 0);\r\n    public acc: Vector = new Vector(0, 0);\r\n\r\n    public angularVelocity: number = 0;\r\n}","export class Vector {\r\n    constructor(public x: number, public y: number) {}\r\n    distance(other?: Vector) {\r\n        if (!other) {\r\n            other = new Vector(0, 0);\r\n        }\r\n        const dx = this.x - other.x;\r\n        const dy = this.y - other.y;\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n\r\n    squareDistance(other: Vector) {\r\n        const dx = this.x - other.x;\r\n        const dy = this.y - other.y;\r\n        return dx * dx + dy * dy;\r\n    }\r\n\r\n    normalize(): Vector {\r\n        const d = this.distance(new Vector(0, 0));\r\n        return new Vector(this.x / d, this.y / d);\r\n    }\r\n\r\n    size(): number {\r\n        return this.distance(new Vector(0, 0));\r\n    }\r\n\r\n    scale(val: number): Vector {\r\n        return new Vector(this.x * val, this.y * val);\r\n    }\r\n\r\n    negate(): Vector {\r\n        return this.scale(-1);\r\n    }\r\n\r\n    /**\r\n     * Returns the perpendicular vector to this one\r\n     */\r\n    perpendicular(): Vector {\r\n        return new Vector(this.y, -this.x);\r\n    }\r\n\r\n    /**\r\n     * Returns the normal vector to this one, same as the perpendicular of length 1\r\n     */\r\n    normal(): Vector {\r\n        return this.perpendicular().normalize();\r\n    }\r\n\r\n    dot(other: Vector): number {\r\n        return this.x * other.x + this.y * other.y;\r\n    }\r\n\r\n    /**\r\n     * Performs a 2D cross product with scalar. 2D cross products with a scalar return a vector.\r\n     * @param v  The scalar to cross\r\n     */\r\n    cross(v: number): Vector;\r\n    /**\r\n     * Performs a 2D cross product with another vector. 2D cross products return a scalar value not a vector.\r\n     * @param v  The vector to cross\r\n     */\r\n    cross(v: Vector): number;\r\n    cross(v: number | Vector): number | Vector {\r\n        if (v instanceof Vector) {\r\n            return this.x * v.y - this.y * v.x;\r\n        } else {\r\n            return new Vector(v * this.y, -v * this.x);\r\n        }\r\n    }\r\n\r\n    add(other: Vector): Vector {\r\n        return new Vector(this.x + other.x, this.y + other.y);\r\n    }\r\n\r\n    /**\r\n     * Creates a vector in the direcion of `other` -> `this`\r\n     * @param other \r\n     * @returns \r\n     */\r\n    sub(other: Vector): Vector {\r\n        return new Vector(this.x - other.x, this.y - other.y);\r\n    }\r\n\r\n\r\n    /**\r\n     * Rotates the current vector around a point by a certain number of\r\n     * degrees in radians\r\n     */\r\n    rotate(angle: number, anchor?: Vector): Vector {\r\n        if (!anchor) {\r\n            anchor = new Vector(0, 0);\r\n        }\r\n        const sinAngle = Math.sin(angle);\r\n        const cosAngle = Math.cos(angle);\r\n        const x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;\r\n        const y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;\r\n        return new Vector(x, y);\r\n    }\r\n\r\n    static cross(num: number, vec: Vector) {\r\n        return new Vector(-num * vec.y, num * vec.x)\r\n    }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { Box } from \"./box\";\r\nimport { Circle } from \"./circle\";\r\nimport { Collider } from \"./collider\";\r\nimport { Contact } from \"./contact\";\r\nimport { Line } from \"./line\";\r\nimport { clamp } from \"./math\";\r\nimport { Solver } from \"./solver\";\r\nimport { Vector } from \"./vector\";\r\n\r\nconst canvas = document.createElement('canvas');\r\ncanvas.width = 800;\r\ncanvas.height = 600;\r\nconst ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\r\ndocument.body.appendChild(canvas);\r\n\r\n\r\nconst gui = new dat.GUI({ name: 'Iterative Solver' });\r\nconst flags: Record<string, number | boolean> = {\r\n    \"Debug\": true,\r\n    \"Points\": true,\r\n    \"Normals\": true,\r\n    \"RelativeVel\": true,\r\n    \"Warming\": true,\r\n    \"Steering Factor\": .2,\r\n    \"Slop\": .5,\r\n    \"Position Iterations\": 3,\r\n    \"Velocity Iterations\": 8,\r\n    \"Gravity Value\": 400,\r\n    \"Gravity\": false\r\n}\r\nfor (let key in flags) {\r\n    if (typeof flags[key] === 'number') {\r\n        switch(key) {\r\n            case \"Steering Factor\": {\r\n                gui.add(flags, key, .05, 1, .05);\r\n                break;\r\n            }\r\n            case \"Slop\": {\r\n                gui.add(flags, key, .5, 5, .5);\r\n                break;\r\n            }\r\n            case \"Gravity Value\": {\r\n                gui.add(flags, key, 0, 1000, 1);\r\n                break;\r\n            }\r\n            default: {\r\n                gui.add(flags, key, 0, 20, 1);\r\n            }\r\n        }\r\n    }\r\n    if (typeof flags[key] === 'boolean') {\r\n        gui.add(flags, key);\r\n    }\r\n}\r\n\r\nconst entities: Collider[] = [\r\n    // new Line(new Vector(50, 550), new Vector(750, 550)),\r\n    new Box(500, 20, new Vector(canvas.width / 2, 550)),\r\n    new Line(new Vector(100, 100), new Vector(300, 650)),\r\n    new Line(new Vector(500, 650), new Vector(700, 100)),\r\n    // new Circle(40, new Vector(canvas.width / 2, 400)),\r\n    // new Box(40, 40, new Vector(canvas.width / 2, 400)),\r\n    // new Circle(40, new Vector(canvas.width / 2, 300)),\r\n    // new Circle(40, new Vector(canvas.width / 2, 200)),\r\n    // new Circle(40, new Vector(canvas.width / 2, 100)),\r\n    // new Circle(40, new Vector(canvas.width / 2, 0)),\r\n    // new Circle(40, new Vector(canvas.width / 2, -100)),\r\n    // new Circle(40, new Vector(canvas.width / 2, -200)),\r\n];\r\n(window as any).entities = entities;\r\nentities[0].static = true;\r\n// entities[entities.length - 1].xf.rotation = Math.PI / 5;\r\n\r\nlet solver = new Solver(flags);\r\nlet contacts: Contact[] = [];\r\nconst update = (elapsed: number) => {\r\n    let acc = new Vector(0, 0);\r\n    if (flags['Gravity']) {\r\n        acc = new Vector(0, flags['Gravity Value'] as number);\r\n    }\r\n\r\n    // Integrate motion\r\n    for (let circle of entities) {\r\n        if (!circle.static) {\r\n            circle.m.vel = circle.m.vel.add(acc.scale(elapsed));\r\n            circle.m.angularVelocity = clamp(circle.m.angularVelocity, -1, 1);\r\n        }\r\n    }\r\n\r\n    // Naive descrete collision detection (broadphase + narrowphase)\r\n    // We re-use contacts from the previous frame if they exist\r\n    contacts = []\r\n    for (let i = 0; i < entities.length; i++) {\r\n        for (let j = i + 1; j < entities.length; j++) {\r\n            let colliderA = entities[i];\r\n            let colliderB = entities[j];\r\n            let contact = colliderA.collide(colliderB);\r\n            if (contact) {\r\n                contacts.push(contact);\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n    // Initialize contact information\r\n    solver.preSolve(contacts);\r\n    \r\n    // Warm start impulses for velocity constraint\r\n    // This helps with simulation coherence by reusing work from previous frames\r\n    // Practically this will cancel gravity on big stacks\r\n    if (flags[\"Warming\"]) {\r\n        solver.warmStart(contacts);\r\n    } else {\r\n        for (let contact of contacts) {\r\n            let contactPoints = solver.getContactPoints(contact.id);\r\n            for (let point of contactPoints) {\r\n                point.normalImpulse = 0;\r\n                point.tangentImpulse = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    // The velocity constraint is that no contacts are moving relative to each other along the normal\r\n    // in other words relative velocity between contacts should approach 0 on the normal\r\n    for (let i = 0; i < flags['Velocity Iterations']; i++) {\r\n        solver.solveVelocity(contacts);\r\n    }\r\n\r\n    // Integrate positions\r\n    for (let circle of entities) {\r\n        if (!circle.static) {\r\n            let offset = circle.m.vel.scale(elapsed).add(acc.scale(0.5 * elapsed * elapsed));\r\n            circle.xf.pos = circle.xf.pos.add(offset);\r\n            circle.xf.rotation += clamp(circle.m.angularVelocity, -1, 1) * elapsed;\r\n            while (circle.xf.rotation > Math.PI * 2) {\r\n                circle.xf.rotation -= Math.PI * 2;\r\n            }\r\n            while (circle.xf.rotation < 0) {\r\n                circle.xf.rotation += Math.PI * 2;\r\n            }\r\n        }\r\n    }\r\n\r\n    // The constraint is separation should approach 0\r\n    for (let i = 0; i < flags['Position Iterations']; i++) {\r\n        solver.solvePosition(contacts);\r\n    }\r\n\r\n    solver.postSolve(contacts);\r\n}\r\n\r\n\r\nconst draw = (elapsed: number) => {\r\n    ctx.save();\r\n    ctx.fillStyle = 'black';\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n    for (let e of entities) {\r\n        e.draw(ctx, flags);\r\n    }\r\n\r\n    if (flags[\"Debug\"]) {\r\n        for (let contact of contacts) {\r\n            let contactPoints = solver.getContactPoints(contact.id);\r\n            for (let p of contactPoints) {\r\n                if (flags[\"Points\"]) {\r\n                    ctx.beginPath();\r\n                    ctx.strokeStyle = 'yellow'\r\n                    ctx.arc(p.point.x, p.point.y, 5, 0, Math.PI * 2);\r\n                    ctx.closePath();\r\n                    ctx.stroke();\r\n                }\r\n\r\n                if (flags[\"Normals\"]) {\r\n                    ctx.beginPath();\r\n                    ctx.strokeStyle = 'red'\r\n                    ctx.moveTo(p.point.x, p.point.y);\r\n                    ctx.lineTo(p.point.x + contact.normal.x * 10, p.point.y + contact.normal.y * 10);\r\n                    ctx.closePath();\r\n                    ctx.stroke();\r\n                }\r\n\r\n                if (flags[\"RelativeVel\"]) {\r\n                    ctx.beginPath();\r\n                    ctx.strokeStyle = 'blue'\r\n                    ctx.moveTo(p.point.x, p.point.y);\r\n                    ctx.lineTo(p.point.x + p.getRelativeVelocity().x, p.point.y + p.getRelativeVelocity().y);\r\n                    ctx.closePath();\r\n                    ctx.stroke();\r\n                }\r\n\r\n                if (flags[\"Impulse\"]) {\r\n                    ctx.fillStyle = 'yellow';\r\n                    ctx.fillText('N- ' + p.normalImpulse.toFixed(1), p.point.x + 10, p.point.y);\r\n                    ctx.fillText('T- ' + p.tangentImpulse.toFixed(1), p.point.x + 10, p.point.y + 10);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let circle of entities) {\r\n            \r\n            ctx.beginPath();\r\n            ctx.strokeStyle = 'green';\r\n            ctx.moveTo(circle.xf.pos.x, circle.xf.pos.y);\r\n            ctx.lineTo(circle.xf.pos.x + circle.m.vel.x, circle.xf.pos.y + circle.m.vel.y);\r\n            ctx.closePath();\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    ctx.restore();\r\n}\r\n\r\nlet singleStep = false;\r\nlet lastMs = 0;\r\nconst mainloop = (currentMs: number) => {\r\n    if (singleStep) {\r\n        return;\r\n    }\r\n\r\n    let seconds = (currentMs - lastMs) / 1000;\r\n    if (seconds > .1) {\r\n        seconds = .016;\r\n    }\r\n\r\n    update(seconds);\r\n    draw(seconds);\r\n\r\n    lastMs = currentMs;\r\n    requestAnimationFrame(mainloop);\r\n}\r\n\r\nmainloop(.016);\r\n\r\ndocument.addEventListener('keydown', (ev) => {\r\n    if (ev.code === 'KeyS') {\r\n        singleStep = true;\r\n        update(.016);\r\n        draw(.016);\r\n    }\r\n    if (ev.code === 'KeyT') {\r\n        singleStep = false;\r\n        lastMs = 0;\r\n        mainloop(.016);\r\n    }\r\n\r\n    if (ev.code === 'KeyI') {\r\n        entities[3].applyImpulse(entities[3].xf.pos, new Vector(0, -5500));\r\n        entities[4].applyImpulse(entities[4].xf.pos, new Vector(0, 5500));\r\n    }\r\n\r\n    if (ev.code === 'KeyC') {\r\n        entities.push(new Circle(40, new Vector(canvas.width / 2, 0)));\r\n    }\r\n\r\n    if (ev.code === 'KeyB') {\r\n        let box = new Box(100, 40, new Vector(canvas.width / 2, 300));\r\n        box.bounciness = .1;\r\n        entities.push(box);\r\n    }\r\n})\r\n"],"sourceRoot":""}