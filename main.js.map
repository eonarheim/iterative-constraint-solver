{"version":3,"sources":["webpack://test-iterative-solver/./circle.ts","webpack://test-iterative-solver/./collider.ts","webpack://test-iterative-solver/./contact.ts","webpack://test-iterative-solver/./line.ts","webpack://test-iterative-solver/./math.ts","webpack://test-iterative-solver/./solver.ts","webpack://test-iterative-solver/./transform.ts","webpack://test-iterative-solver/./vector.ts","webpack://test-iterative-solver/webpack/bootstrap","webpack://test-iterative-solver/./main.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,wEAAsC;AACtC,qEAAoC;AACpC,4DAA8B;AAI9B;IAA4B,0BAAQ;IAChC,gBAAmB,MAAc,EAAE,GAAW;QAA9C,YACI,iBAAO,SAGV;QAJkB,YAAM,GAAN,MAAM,CAAQ;QAE7B,KAAI,CAAC,EAAE,CAAC,GAAG,GAAG,GAAG,CAAC;QAClB,KAAI,CAAC,IAAI,GAAG,MAAM,CAAC;;IACvB,CAAC;IAED,sBAAI,+BAAW;aAAf;YACI,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC;QAC3C,CAAC;;;OAAA;IAED,sBAAI,2BAAO;aAAX;YACI,OAAO,CAAC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QACvD,CAAC;;;OAAA;IAED,sBAAI,kCAAc;aAAlB;YACI,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC;QAC9C,CAAC;;;OAAA;IAED;;;;OAIG;IACH,wBAAO,GAAP,UAAQ,KAAoB,EAAE,OAAiB;;QAC3C,IAAI,KAAK,YAAY,MAAM,EAAE;YACzB,IAAM,cAAc,GAAG,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;YAClD,IAAM,QAAQ,GAAG,KAAK,CAAC,EAAE,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;YACpD,IAAI,QAAQ,GAAG,cAAc,EAAE;gBAC3B,IAAM,UAAU,GAAG,cAAc,GAAG,QAAQ,CAAC;gBAC7C,4BAA4B;gBAC5B,IAAM,SAAS,GAAG,KAAK,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;gBAChD,IAAM,MAAM,GAAG,SAAS,CAAC,SAAS,EAAE,CAAC;gBACrC,IAAM,OAAO,GAAG,MAAM,CAAC,aAAa,EAAE,CAAC;gBACvC,IAAM,KAAK,GAAG,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;gBACzD,OAAO,IAAI,iBAAO,CAAC,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;aAC7D;YACD,OAAO,IAAI,CAAC;SACf;QAED,IAAI,KAAK,YAAY,WAAI,EAAE;YACvB,wBAAwB;YACxB,IAAM,CAAC,GAAG,WAAK,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,mCAAI,IAAI,CAAC;YAC/C,OAAO,CAAC,CAAC;SACZ;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;;OAKG;IACH,6BAAY,GAAZ,UAAa,KAAa,EAAE,OAAe;QACvC,IAAI,IAAI,CAAC,MAAM,EAAE;YACb,OAAO;SACV;QAED,IAAM,kBAAkB,GAAG,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;QAElD,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;QAC7D,IAAI,CAAC,CAAC,CAAC,eAAe,IAAI,IAAI,CAAC,cAAc,GAAG,kBAAkB,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;IACtF,CAAC;IACL,aAAC;AAAD,CAAC,CAjE2B,mBAAQ,GAiEnC;AAjEY,wBAAM;;;;;;;;;;;;;;ACJnB,2EAAgD;AAGhD;IAAA;QAEW,OAAE,GAAG,QAAQ,CAAC,GAAG,EAAE,CAAC;QACpB,WAAM,GAAG,KAAK,CAAC;QACf,SAAI,GAAG,CAAC,CAAC;QAET,eAAU,GAAG,GAAG,CAAC;QACjB,aAAQ,GAAG,GAAG,CAAC;QACf,OAAE,GAAG,IAAI,qBAAS,EAAE,CAAC;QACrB,MAAC,GAAG,IAAI,kBAAM,EAAE,CAAC;IAkD5B,CAAC;IAhDG,sBAAI,iCAAW;aAAf;YACI,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC;QAC3C,CAAC;;;OAAA;IAED,sBAAI,6BAAO;aAAX;YACI,OAAO,IAAI,CAAC,IAAI,CAAC;QACrB,CAAC;;;OAAA;IAED,sBAAI,oCAAc;aAAlB;YACI,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC;QAC9C,CAAC;;;OAAA;IAED;;;;;OAKG;IACH,+BAAY,GAAZ,UAAa,KAAa,EAAE,OAAe;QACvC,IAAI,IAAI,CAAC,MAAM,EAAE;YACb,OAAO;SACV;QAED,IAAM,kBAAkB,GAAG,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;QAElD,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;QAC7D,IAAI,CAAC,CAAC,CAAC,eAAe,IAAI,IAAI,CAAC,cAAc,GAAG,kBAAkB,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;IACtF,CAAC;IAED,qCAAkB,GAAlB,UAAmB,OAAe;QAC9B,IAAI,IAAI,CAAC,MAAM,EAAE;YACb,OAAO;SACV;QAED,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;IACjE,CAAC;IAED,sCAAmB,GAAnB,UAAoB,KAAa,EAAE,OAAe;QAC9C,IAAI,IAAI,CAAC,MAAM,EAAE;YACb,OAAO;SACV;QAED,IAAM,kBAAkB,GAAG,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;QAElD,IAAI,CAAC,CAAC,CAAC,eAAe,IAAI,IAAI,CAAC,cAAc,GAAG,kBAAkB,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;IACtF,CAAC;IAvDc,YAAG,GAAG,CAAC,CAAC;IA0D3B,eAAC;CAAA;AA3DqB,4BAAQ;;;;;;;;;;;;;;ACL9B,kEAAkC;AAElC,4DAA8B;AAE9B,kEAAyC;AAEzC;;GAEG;AACH;IAEI,sBAAmB,KAAa,EAAS,OAAgB;QAAtC,UAAK,GAAL,KAAK,CAAQ;QAAS,YAAO,GAAP,OAAO,CAAS;QAazD;;WAEG;QACI,kBAAa,GAAW,CAAC,CAAC;QAEjC;;WAEG;QACI,mBAAc,GAAW,CAAC,CAAC;QAElC;;WAEG;QACI,eAAU,GAAW,CAAC,CAAC;QAE9B;;WAEG;QACI,gBAAW,GAAW,CAAC,CAAC;QAE/B;;WAEG;QACI,eAAU,GAAW,IAAI,eAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAE7C;;WAEG;QACI,eAAU,GAAW,IAAI,eAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAzCe,CAAC;IAEtD,0CAAmB,GAA1B;QACI,IAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC;QACjC,IAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC;QACjC,oCAAoC;QACpC,6FAA6F;QAC7F,IAAM,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,cAAK,CAAC,KAAK,CAAC,CAAC,CAAC,eAAe,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,CACzE,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,cAAK,CAAC,KAAK,CAAC,CAAC,CAAC,eAAe,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;QAEzE,OAAO,GAAG,CAAC;IACf,CAAC;IA+BL,mBAAC;AAAD,CAAC;AA5CY,oCAAY;AA8CzB;;;;GAIG;AACH;IA8CI,iBACW,KAAe,EACf,KAAe,EACf,MAAc,EACd,OAAe,EACf,MAAqB;QAArB,oCAAqB;QAJrB,UAAK,GAAL,KAAK,CAAU;QACf,UAAK,GAAL,KAAK,CAAU;QACf,WAAM,GAAN,MAAM,CAAQ;QACd,YAAO,GAAP,OAAO,CAAQ;QACf,WAAM,GAAN,MAAM,CAAe;IAC7B,CAAC;IA/CJ,sBAAW,uBAAE;QAHb;;WAEG;aACH;YACI,OAAO,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;QACjD,CAAC;;;OAAA;IAED;;;;;OAKG;IACW,aAAK,GAAnB,UAAoB,KAAe,EAAE,KAAe;QAChD,IAAI,KAAK,CAAC,EAAE,GAAG,KAAK,CAAC,EAAE,EAAE;YACrB,OAAU,KAAK,CAAC,EAAE,SAAI,KAAK,CAAC,EAAI,CAAC;SACpC;aAAM;YACH,OAAU,KAAK,CAAC,EAAE,SAAI,KAAK,CAAC,EAAI,CAAC;SACpC;IACL,CAAC;IAED;;;OAGG;IACI,+BAAa,GAApB;QACI,IAAI,IAAI,CAAC,KAAK,YAAY,eAAM,IAAI,IAAI,CAAC,KAAK,YAAY,eAAM,EAAE;YAC9D,IAAM,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;YAC7D,IAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;YAC/D,IAAM,UAAU,GAAG,cAAc,GAAG,QAAQ,CAAC;YAC7C,OAAO,CAAC,UAAU,CAAC;SACtB;QAED,IAAI,IAAI,CAAC,KAAK,YAAY,eAAM,IAAI,IAAI,CAAC,KAAK,YAAY,WAAI,EAAE;YAC5D,OAAO,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SAC/C;QAED,IAAI,IAAI,CAAC,KAAK,YAAY,WAAI,IAAI,IAAI,CAAC,KAAK,YAAY,eAAM,EAAE;YAC5D,OAAO,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SAC/C;QAED,OAAO,CAAC;IACZ,CAAC;IASL,cAAC;AAAD,CAAC;AArDY,0BAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5DpB,kEAAkC;AAClC,wEAAsC;AACtC,qEAAoC;AAIpC;IAA0B,wBAAQ;IAE9B,cAAmB,KAAa,EAAS,GAAW;QAApD,YACI,iBAAO,SAEV;QAHkB,WAAK,GAAL,KAAK,CAAQ;QAAS,SAAG,GAAH,GAAG,CAAQ;QADpD,YAAM,GAAG,IAAI,CAAC;QAGV,KAAI,CAAC,EAAE,CAAC,GAAG,GAAG,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;;IAC3C,CAAC;IAED,4BAAa,GAAb,UAAc,KAAa;QACvB,uBAAuB;QACvB,IAAM,EAAE,GAAG,KAAK,CAAC,EAAE,CAAC,GAAG,CAAC;QACxB,sCAAsC;QACtC,IAAM,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACnC,sEAAsE;QACtE,IAAM,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;QAClC,IAAM,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QAEpC,IAAM,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;QACrB,IAAM,WAAW,GAAG,IAAI,CAAC,KAAK;aACzB,KAAK,CAAC,CAAC,CAAC;aACR,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;aACtB,KAAK,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;QACpB,IAAM,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QAE9B,IAAM,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;QAEpB,IAAM,GAAG,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;QAEpD,OAAO,GAAG,CAAC;IACf,CAAC;IAED,sBAAO,GAAP,UAAQ,KAAoB,EAAE,OAAiB;QAC3C,IAAI,KAAK,YAAY,eAAM,EAAE;YAEzB,uBAAuB;YACvB,IAAM,EAAE,GAAG,KAAK,CAAC,EAAE,CAAC,GAAG,CAAC;YACxB,sCAAsC;YACtC,IAAM,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAEnC,sEAAsE;YACtE,IAAM,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;YAClC,IAAM,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;YAEpC,8FAA8F;YAC9F,IAAI,CAAC,IAAI,CAAC,EAAE;gBACR,IAAM,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;gBAC9B,IAAM,GAAG,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,uEAAuE;gBAC/F,kBAAkB;gBAClB,IAAI,GAAG,GAAG,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,EAAE;oBACnC,OAAO,IAAI,CAAC,CAAC,eAAe;iBAC/B;gBACD,iBAAiB;gBACjB,IAAI,UAAU,GAAG,EAAE,CAAC,SAAS,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;gBACrE,IAAI,MAAM,GAAG,EAAE,CAAC,SAAS,EAAE,CAAC;gBAC5B,OAAO,IAAI,iBAAO,CAAC,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,CAAC,aAAa,EAAE,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;aACjF;YAED,wFAAwF;YACxF,IAAI,CAAC,IAAI,CAAC,EAAE;gBACR,IAAM,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;gBAC5B,IAAM,GAAG,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;gBACvB,IAAI,GAAG,GAAG,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,EAAE;oBACnC,OAAO,IAAI,CAAC;iBACf;gBACD,iBAAiB;gBACjB,IAAI,UAAU,GAAG,EAAE,CAAC,SAAS,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;gBACrE,IAAI,MAAM,GAAG,EAAE,CAAC,SAAS,EAAE,CAAC;gBAC5B,OAAO,IAAI,iBAAO,CAAC,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,CAAC,aAAa,EAAE,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;aAC/E;YAED,8GAA8G;YAC9G,IAAM,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YACrB,IAAM,WAAW,GAAG,IAAI,CAAC,KAAK;iBACzB,KAAK,CAAC,CAAC,CAAC;iBACR,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;iBACtB,KAAK,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;YACpB,IAAM,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;YAE9B,IAAM,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YACpB,IAAI,EAAE,GAAG,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,EAAE;gBAClC,OAAO,IAAI,CAAC,CAAC,eAAe;aAC/B;YAED,IAAI,CAAC,GAAG,CAAC,CAAC,aAAa,EAAE,CAAC;YAC1B,yBAAyB;YACzB,IAAI,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,EAAE;gBAC/B,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;gBACX,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;aACd;YAED,CAAC,GAAG,CAAC,CAAC,SAAS,EAAE,CAAC;YAElB,IAAM,GAAG,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YAE5D,iBAAiB;YACjB,OAAO,IAAI,iBAAO,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,aAAa,EAAE,EAAE,CAAC,WAAW,CAAC,CAAC,CAAC;SACxE;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IACL,WAAC;AAAD,CAAC,CAnGyB,mBAAQ,GAmGjC;AAnGY,oBAAI;;;;;;;;;;;;;;ACNV,IAAM,KAAK,GAAG,UAAC,GAAW,EAAE,GAAW,EAAE,GAAW;IACvD,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC;AAC7C,CAAC;AAFY,aAAK,SAEjB;AAEM,IAAM,MAAM,GAAG,UAAC,YAAqB,EAAE,OAAe;IACzD,IAAI,CAAC,YAAY,EAAE;QACf,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC;KAC3B;AACL,CAAC;AAJY,cAAM,UAIlB;AAEM,IAAM,OAAO,GAAG,UAAC,IAAW;IACjC,gBAAgB;IAChB,IAAI,YAAY,GAAG,IAAI,CAAC,MAAM,CAAC;IAC/B,IAAI,WAAW,GAAG,CAAC,CAAC;IACpB,IAAI,GAAG,GAAG,IAAI,CAAC;IACf,OAAO,YAAY,GAAG,CAAC,EAAE;QACrB,8BAA8B;QAChC,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,YAAY,CAAC,CAAC;QACvD,YAAY,EAAE,CAAC;QAEf,wCAAwC;QACxC,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC,CAAC;QACzB,IAAI,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC;QACvC,IAAI,CAAC,WAAW,CAAC,GAAG,GAAG,CAAC;KACzB;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAhBY,eAAO,WAgBnB;;;;;;;;;;;;;;AC1BD,qEAAkD;AAClD,4DAAuC;AAEvC;IAAA;QACI,sBAAiB,GAAyB,IAAI,GAAG,EAAE,CAAC;QAEpD,mCAAmC;QACnC,sBAAiB,GAAgC,IAAI,GAAG,EAAE,CAAC;IA6L/D,CAAC;IA3LG,iCAAgB,GAAhB,UAAiB,EAAU;;QACvB,OAAO,UAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,EAAE,CAAC,mCAAI,EAAE,CAAC;IAChD,CAAC;IAED,yBAAQ,GAAR,UAAS,QAAmB;;QACxB,mCAAmC;QACnC,IAAI,kBAAkB,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,CAAC,CAAC;QACnE,KAAoB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ,EAAE;YAAzB,IAAI,OAAO;YACZ,gDAAgD;YAChD,IAAI,KAAK,GAAG,kBAAkB,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;YACnD,IAAI,KAAK,GAAG,CAAC,CAAC,EAAE;gBACZ,kBAAkB,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;aACvC;YACD,IAAI,aAAa,GAAG,UAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,mCAAI,EAAE,CAAC;YAEjE,IAAI,UAAU,GAAG,CAAC,CAAC;YACnB,KAAkB,UAAc,EAAd,YAAO,CAAC,MAAM,EAAd,cAAc,EAAd,IAAc,EAAE;gBAA7B,IAAI,KAAK;gBACV,IAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;gBAC5B,IAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;gBAC5B,IAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;gBAC9B,IAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;gBAEhC,IAAM,UAAU,GAAG,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;gBAC3C,IAAM,UAAU,GAAG,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;gBAE3C,IAAM,gBAAgB,GAAG,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;gBAClD,IAAM,gBAAgB,GAAG,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;gBAElD,IAAM,UAAU,GAAG,KAAK,CAAC,WAAW,GAAG,KAAK,CAAC,WAAW;oBACxC,KAAK,CAAC,cAAc,GAAG,gBAAgB,GAAG,gBAAgB;oBAC1D,KAAK,CAAC,cAAc,GAAG,gBAAgB,GAAG,gBAAgB,CAAC;gBAE3E,IAAM,iBAAiB,GAAG,UAAU,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;gBACpD,IAAM,iBAAiB,GAAG,UAAU,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;gBAEpD,IAAM,WAAW,GAAG,KAAK,CAAC,WAAW,GAAG,KAAK,CAAC,WAAW;oBACzC,KAAK,CAAC,cAAc,GAAG,iBAAiB,GAAG,iBAAiB;oBAC5D,KAAK,CAAC,cAAc,GAAG,iBAAiB,GAAG,iBAAiB,CAAC;gBAE7E,8EAA8E;gBAC9E,IAAI,aAAa,CAAC,UAAU,CAAC,IAAI,0BAAa,CAAC,UAAU,CAAC,0CAAE,KAAK,0CAAE,cAAc,CAAC,KAAK,CAAC,IAAG,CAAC,EAAE;oBAC1F,aAAa,CAAC,UAAU,CAAC,CAAC,KAAK,GAAG,KAAK,CAAC;iBAC3C;qBAAM;oBACH,iDAAiD;oBACjD,aAAa,CAAC,UAAU,CAAC,GAAG,IAAI,sBAAY,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;iBAChE;gBAED,oCAAoC;gBACpC,aAAa,CAAC,UAAU,CAAC,CAAC,UAAU,GAAG,UAAU,CAAC;gBAClD,aAAa,CAAC,UAAU,CAAC,CAAC,UAAU,GAAG,UAAU,CAAC;gBAClD,aAAa,CAAC,UAAU,CAAC,CAAC,UAAU,GAAG,UAAU,CAAC;gBAClD,aAAa,CAAC,UAAU,CAAC,CAAC,WAAW,GAAG,WAAW,CAAC;gBAEpD,UAAU,EAAE;aACf;YACD,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,EAAE,aAAa,CAAC,CAAC;SACzD;QAED,sDAAsD;QACtD,KAAiB,UAAkB,EAAlB,yCAAkB,EAAlB,gCAAkB,EAAlB,IAAkB,EAAE;YAAhC,IAAM,EAAE;YACT,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;SACrC;IACL,CAAC;IAED,0BAAS,GAAT,UAAU,QAAmB;QACzB,iBAAiB;QACjB,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,CAAC;QAC/B,KAAgB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ,EAAE;YAArB,IAAM,CAAC;YACR,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;SACvC;IACL,CAAC;IAED;;;OAGG;IACH,0BAAS,GAAT,UAAU,QAAmB;;QACzB,KAAoB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ,EAAE;YAAzB,IAAI,OAAO;YACZ,IAAI,aAAa,GAAG,UAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,mCAAI,EAAE,CAAC;YACjE,KAAkB,UAAa,EAAb,+BAAa,EAAb,2BAAa,EAAb,IAAa,EAAE;gBAA5B,IAAI,KAAK;gBAEV,IAAM,aAAa,GAAG,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;gBAChE,sEAAsE;gBACtE,IAAM,cAAc,GAAG,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;gBAC7E,IAAM,OAAO,GAAG,aAAa,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;gBAClD,6DAA6D;gBAC7D,oDAAoD;gBAEpD,OAAO,CAAC,KAAK,CAAC,kBAAkB,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,CAAC;gBACzD,OAAO,CAAC,KAAK,CAAC,mBAAmB,CAAC,KAAK,CAAC,KAAK,EAAE,cAAc,CAAC,MAAM,EAAE,CAAC,CAAC;gBAExE,OAAO,CAAC,KAAK,CAAC,kBAAkB,CAAC,aAAa,CAAC,CAAC;gBAChD,OAAO,CAAC,KAAK,CAAC,mBAAmB,CAAC,KAAK,CAAC,KAAK,EAAE,cAAc,CAAC,CAAC;aAClE;SACJ;IACL,CAAC;IAED;;;OAGG;IACH,8BAAa,GAAb,UAAc,QAAmB;;QAC7B,KAAoB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ,EAAE;YAAzB,IAAI,OAAO;YACZ,IAAI,aAAa,GAAG,UAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,mCAAI,EAAE,CAAC;YACjE,KAAkB,UAAa,EAAb,+BAAa,EAAb,2BAAa,EAAb,IAAa,EAAE;gBAA5B,IAAI,KAAK;gBACV,IAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;gBAC5B,IAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;gBAC5B,IAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;gBAC9B,IAAM,UAAU,GAAG,OAAO,CAAC,aAAa,EAAE,CAAC;gBAE3C,IAAM,gBAAgB,GAAG,GAAG;gBAC5B,IAAM,aAAa,GAAG,CAAC,CAAC,CAAC;gBACzB,IAAM,IAAI,GAAG,CAAC,CAAC;gBACf,iCAAiC;gBACjC,yDAAyD;gBACzD,IAAM,aAAa,GAAG,YAAK,CAAC,gBAAgB,GAAG,CAAC,UAAU,GAAG,IAAI,CAAC,EAAE,aAAa,EAAE,CAAC,CAAC,CAAC;gBACtF,IAAM,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,aAAa,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC;gBAGhE,+EAA+E;gBAC/E,gEAAgE;gBAChE,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;oBACf,KAAK,CAAC,EAAE,CAAC,GAAG,GAAG,KAAK,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC;oBAC3E,KAAK,CAAC,EAAE,CAAC,QAAQ,IAAI,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,KAAK,CAAC,cAAc,CAAC;iBAC/E;gBAED,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;oBACf,KAAK,CAAC,EAAE,CAAC,GAAG,GAAG,KAAK,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC;oBAClE,KAAK,CAAC,EAAE,CAAC,QAAQ,IAAI,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,KAAK,CAAC,cAAc,CAAC;iBAC/E;aAEJ;SACJ;IACL,CAAC;IAED,8BAAa,GAAb,UAAc,QAAmB;;QAC7B,KAAoB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ,EAAE;YAAzB,IAAI,OAAO;YACZ,IAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;YAC5B,IAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;YAE5B,IAAM,WAAW,GAAG,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC,UAAU,CAAC;YACxD,IAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,QAAQ,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAC;YAC1D,IAAI,aAAa,GAAG,UAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,mCAAI,EAAE,CAAC;YAEjE,KAAkB,UAAa,EAAb,+BAAa,EAAb,2BAAa,EAAb,IAAa,EAAE;gBAA5B,IAAI,KAAK;gBACV,IAAM,gBAAgB,GAAG,KAAK,CAAC,mBAAmB,EAAE,CAAC;gBAErD,4DAA4D;gBAC5D,IAAM,eAAe,GAAG,CAAC,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;gBAC/D,IAAI,YAAY,GAAG,eAAe,GAAG,KAAK,CAAC,WAAW,CAAC;gBAEvD,+CAA+C;gBAC/C,mHAAmH;gBACnH,kFAAkF;gBAClF,sBAAsB;gBACtB,IAAM,WAAW,GAAG,QAAQ,GAAG,KAAK,CAAC,aAAa,CAAC;gBACnD,IAAM,UAAU,GAAG,YAAK,CAAC,KAAK,CAAC,cAAc,GAAG,YAAY,EAAE,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;gBACzF,YAAY,GAAG,UAAU,GAAG,KAAK,CAAC,cAAc,CAAC;gBACjD,KAAK,CAAC,cAAc,GAAG,UAAU,CAAC;gBAElC,IAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;gBACpD,KAAK,CAAC,YAAY,CAAC,KAAK,CAAC,KAAK,EAAE,OAAO,CAAC,MAAM,EAAE,CAAC,CAAC;gBAClD,KAAK,CAAC,YAAY,CAAC,KAAK,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;aAC5C;YAED,KAAkB,UAAa,EAAb,+BAAa,EAAb,2BAAa,EAAb,IAAa,EAAE;gBAA5B,IAAI,KAAK;gBACV,oFAAoF;gBACpF,IAAM,gBAAgB,GAAG,KAAK,CAAC,mBAAmB,EAAE,CAAC;gBAErD,sCAAsC;gBACtC,IAAM,cAAc,GAAG,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;gBAC5D,uDAAuD;gBACvD,IAAI,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,GAAG,cAAc,CAAC,GAAG,KAAK,CAAC,UAAU,CAAC;gBAE5E,+CAA+C;gBAC/C,wEAAwE;gBACxE,6BAA6B;gBAC7B,IAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,aAAa,GAAG,YAAY,EAAE,CAAC,CAAC,CAAC;gBACnE,YAAY,GAAG,UAAU,GAAG,KAAK,CAAC,aAAa,CAAC;gBAChD,KAAK,CAAC,aAAa,GAAG,UAAU,CAAC;gBAEjC,IAAM,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;gBACnD,KAAK,CAAC,YAAY,CAAC,KAAK,CAAC,KAAK,EAAE,OAAO,CAAC,MAAM,EAAE,CAAC,CAAC;gBAClD,KAAK,CAAC,YAAY,CAAC,KAAK,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;aAC5C;SACJ;IACL,CAAC;IACL,aAAC;AAAD,CAAC;AAjMY,wBAAM;;;;;;;;;;;;;;ACHnB,kEAAkC;AAElC;IAAA;QACW,QAAG,GAAW,IAAI,eAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/B,aAAQ,GAAW,CAAC,CAAC;IAChC,CAAC;IAAD,gBAAC;AAAD,CAAC;AAHY,8BAAS;AAKtB;IAAA;QACW,QAAG,GAAW,IAAI,eAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/B,QAAG,GAAW,IAAI,eAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAE/B,oBAAe,GAAW,CAAC,CAAC;IACvC,CAAC;IAAD,aAAC;AAAD,CAAC;AALY,wBAAM;;;;;;;;;;;;;;ACPnB;IACI,gBAAmB,CAAS,EAAS,CAAS;QAA3B,MAAC,GAAD,CAAC,CAAQ;QAAS,MAAC,GAAD,CAAC,CAAQ;IAAG,CAAC;IAClD,yBAAQ,GAAR,UAAS,KAAa;QAClB,IAAM,EAAE,GAAG,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC;QAC5B,IAAM,EAAE,GAAG,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC;QAC5B,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;IACxC,CAAC;IAED,+BAAc,GAAd,UAAe,KAAa;QACxB,IAAM,EAAE,GAAG,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC;QAC5B,IAAM,EAAE,GAAG,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC;QAC5B,OAAO,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;IAC7B,CAAC;IAED,0BAAS,GAAT;QACI,IAAM,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAC1C,OAAO,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IAC9C,CAAC;IAED,qBAAI,GAAJ;QACI,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IAC3C,CAAC;IAED,sBAAK,GAAL,UAAM,GAAW;QACb,OAAO,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,GAAG,EAAE,IAAI,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;IAClD,CAAC;IAED,uBAAM,GAAN;QACI,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IAC1B,CAAC;IAED;;OAEG;IACH,8BAAa,GAAb;QACI,OAAO,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACvC,CAAC;IAED;;OAEG;IACH,uBAAM,GAAN;QACI,OAAO,IAAI,CAAC,aAAa,EAAE,CAAC,SAAS,EAAE,CAAC;IAC5C,CAAC;IAED,oBAAG,GAAH,UAAI,KAAa;QACb,OAAO,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC;IAC/C,CAAC;IAYD,sBAAK,GAAL,UAAM,CAAkB;QACpB,IAAI,CAAC,YAAY,MAAM,EAAE;YACrB,OAAO,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;SACtC;aAAM;YACH,OAAO,IAAI,MAAM,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;SAC9C;IACL,CAAC;IAED,oBAAG,GAAH,UAAI,KAAa;QACb,OAAO,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IAC1D,CAAC;IAED;;;;OAIG;IACH,oBAAG,GAAH,UAAI,KAAa;QACb,OAAO,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IAC1D,CAAC;IACL,aAAC;AAAD,CAAC;AA/EY,wBAAM;AAiFZ,IAAM,KAAK,GAAG,UAAC,GAAW,EAAE,GAAW;IAC1C,OAAO,IAAI,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,EAAE,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC;AAChD,CAAC;AAFY,aAAK,SAEjB;;;;;;;UCnFD;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;;;ACrBA,kEAAkC;AAElC,4DAA8B;AAC9B,4DAAgD;AAChD,kEAAkC;AAClC,kEAAkC;AAElC,IAAM,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;AAChD,MAAM,CAAC,KAAK,GAAG,GAAG,CAAC;AACnB,MAAM,CAAC,MAAM,GAAG,GAAG,CAAC;AACpB,IAAM,GAAG,GAAG,MAAM,CAAC,UAAU,CAAC,IAAI,CAA6B,CAAC;AAChE,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;AAGlC,IAAM,GAAG,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,EAAE,IAAI,EAAE,kBAAkB,EAAE,CAAC,CAAC;AACtD,IAAM,KAAK,GAAqC;IAC5C,OAAO,EAAE,IAAI;IACb,SAAS,EAAE,IAAI;IACf,qBAAqB,EAAE,CAAC;IACxB,qBAAqB,EAAE,CAAC;IACxB,eAAe,EAAE,GAAG;IACpB,SAAS,EAAE,KAAK;CACnB;AACD,KAAK,IAAI,GAAG,IAAI,KAAK,EAAE;IACnB,IAAI,OAAO,KAAK,CAAC,GAAG,CAAC,KAAK,QAAQ,EAAE;QAChC,GAAG,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;KACjC;IACD,IAAI,OAAO,KAAK,CAAC,GAAG,CAAC,KAAK,SAAS,EAAE;QACjC,GAAG,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;KACvB;CACJ;AAED,IAAM,QAAQ,GAAG;IACb,IAAI,WAAI,CAAC,IAAI,eAAM,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,IAAI,eAAM,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IACnD,IAAI,WAAI,CAAC,IAAI,eAAM,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,IAAI,eAAM,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IACpD,IAAI,WAAI,CAAC,IAAI,eAAM,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,IAAI,eAAM,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IACpD,IAAI,eAAM,CAAC,EAAE,EAAE,IAAI,eAAM,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC;IACjD,IAAI,eAAM,CAAC,EAAE,EAAE,IAAI,eAAM,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC;IACjD,qDAAqD;IACrD,qDAAqD;IACrD,mDAAmD;IACnD,sDAAsD;IACtD,sDAAsD;CACzD,CAAC;AACD,MAAc,CAAC,QAAQ,GAAG,QAAQ,CAAC;AAEpC,IAAI,MAAM,GAAG,IAAI,eAAM,EAAE,CAAC;AAC1B,IAAI,QAAQ,GAAc,EAAE,CAAC;AAC7B,IAAM,MAAM,GAAG,UAAC,OAAe;IAC3B,IAAI,GAAG,GAAG,IAAI,eAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC3B,IAAI,KAAK,CAAC,SAAS,CAAC,EAAE;QAClB,GAAG,GAAG,IAAI,eAAM,CAAC,CAAC,EAAE,KAAK,CAAC,eAAe,CAAW,CAAC,CAAC;KACzD;IAED,mBAAmB;IACnB,KAAmB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ,EAAE;QAAxB,IAAI,MAAM;QACX,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YAChB,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;YACpD,MAAM,CAAC,CAAC,CAAC,eAAe,GAAG,YAAK,CAAC,MAAM,CAAC,CAAC,CAAC,eAAe,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,CAAC,CAAC;SACjF;KACJ;IAED,gEAAgE;IAChE,2DAA2D;IAC3D,QAAQ,GAAG,EAAE;IACb,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACtC,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC1C,IAAI,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC1B,IAAI,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC1B,IAAI,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;YACvC,IAAI,OAAO,EAAE;gBACT,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;aAC1B;SAEJ;KACJ;IAED,iCAAiC;IACjC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAE1B,8CAA8C;IAC9C,4EAA4E;IAC5E,qDAAqD;IACrD,IAAI,KAAK,CAAC,SAAS,CAAC,EAAE;QAClB,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;KAC9B;SAAM;QACH,KAAoB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ,EAAE;YAAzB,IAAI,OAAO;YACZ,IAAI,aAAa,GAAG,MAAM,CAAC,gBAAgB,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;YACxD,KAAkB,UAAa,EAAb,+BAAa,EAAb,2BAAa,EAAb,IAAa,EAAE;gBAA5B,IAAI,KAAK;gBACV,KAAK,CAAC,aAAa,GAAG,CAAC,CAAC;gBACxB,KAAK,CAAC,cAAc,GAAG,CAAC,CAAC;aAC5B;SACJ;KACJ;IAED,iGAAiG;IACjG,oFAAoF;IACpF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,qBAAqB,CAAC,EAAE,CAAC,EAAE,EAAE;QACnD,MAAM,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;KAClC;IAED,sBAAsB;IACtB,KAAmB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ,EAAE;QAAxB,IAAI,MAAM;QACX,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YAChB,MAAM,CAAC,EAAE,CAAC,GAAG,GAAG,MAAM,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,GAAG,OAAO,GAAG,OAAO,CAAC,CAAC,CAAC;YACvG,MAAM,CAAC,EAAE,CAAC,QAAQ,IAAI,MAAM,CAAC,CAAC,CAAC,eAAe,GAAG,OAAO,CAAC;YACzD,OAAO,MAAM,CAAC,EAAE,CAAC,QAAQ,GAAG,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE;gBACrC,MAAM,CAAC,EAAE,CAAC,QAAQ,IAAI,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;aACrC;YACD,OAAO,MAAM,CAAC,EAAE,CAAC,QAAQ,GAAG,CAAC,EAAE;gBAC3B,MAAM,CAAC,EAAE,CAAC,QAAQ,IAAI,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;aACrC;SACJ;KACJ;IAED,iDAAiD;IACjD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,qBAAqB,CAAC,EAAE,CAAC,EAAE,EAAE;QACnD,MAAM,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;KAClC;IAED,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;AAC/B,CAAC;AAGD,IAAM,IAAI,GAAG,UAAC,OAAe;IACzB,GAAG,CAAC,IAAI,EAAE,CAAC;IACX,GAAG,CAAC,SAAS,GAAG,OAAO,CAAC;IACxB,GAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;IAEhD,KAAc,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ,EAAE;QAAnB,IAAI,CAAC;QACN,IAAI,CAAC,YAAY,eAAM,EAAE;YACrB,GAAG,CAAC,SAAS,EAAE,CAAC;YAChB,GAAG,CAAC,SAAS,GAAG,MAAM,CAAC;YACvB,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;YAC1D,GAAG,CAAC,SAAS,EAAE,CAAC;YAChB,GAAG,CAAC,IAAI,EAAE,CAAC;YAEX,IAAI,KAAK,CAAC,OAAO,CAAC,EAAE;gBAChB,GAAG,CAAC,SAAS,GAAG,QAAQ,CAAC;gBACzB,GAAG,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;aACvD;YAED,GAAG,CAAC,IAAI,EAAE,CAAC;YACX,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YACtC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC;YAC1B,GAAG,CAAC,SAAS,EAAE;YACf,GAAG,CAAC,WAAW,GAAG,OAAO,CAAC;YAC1B,GAAG,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YACjB,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;YAC5B,GAAG,CAAC,SAAS,EAAE,CAAC;YAChB,GAAG,CAAC,MAAM,EAAE,CAAC;YACb,GAAG,CAAC,OAAO,EAAE,CAAC;SACjB;QAED,IAAI,CAAC,YAAY,WAAI,EAAE;YACnB,GAAG,CAAC,IAAI,EAAE,CAAC;YACX,GAAG,CAAC,SAAS,EAAE,CAAC;YAChB,GAAG,CAAC,WAAW,GAAG,OAAO;YACzB,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACjC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAC7B,GAAG,CAAC,SAAS,EAAE,CAAC;YAChB,GAAG,CAAC,MAAM,EAAE,CAAC;YACb,GAAG,CAAC,OAAO,EAAE,CAAC;YAEd,IAAI,KAAK,CAAC,OAAO,CAAC,EAAE;gBAChB,GAAG,CAAC,SAAS,GAAG,QAAQ,CAAC;gBACzB,GAAG,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;aACvD;SACJ;KACJ;IAED,IAAI,KAAK,CAAC,OAAO,CAAC,EAAE;QAChB,KAAoB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ,EAAE;YAAzB,IAAI,OAAO;YACZ,IAAI,aAAa,GAAG,MAAM,CAAC,gBAAgB,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;YACxD,KAAc,UAAa,EAAb,+BAAa,EAAb,2BAAa,EAAb,IAAa,EAAE;gBAAxB,IAAI,CAAC;gBACN,GAAG,CAAC,SAAS,EAAE,CAAC;gBAChB,GAAG,CAAC,WAAW,GAAG,QAAQ;gBAC1B,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;gBACjD,GAAG,CAAC,SAAS,EAAE,CAAC;gBAChB,GAAG,CAAC,MAAM,EAAE,CAAC;gBAEb,GAAG,CAAC,SAAS,EAAE,CAAC;gBAChB,GAAG,CAAC,WAAW,GAAG,KAAK;gBACvB,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBACjC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC;gBACjF,GAAG,CAAC,SAAS,EAAE,CAAC;gBAChB,GAAG,CAAC,MAAM,EAAE,CAAC;gBAEb,GAAG,CAAC,SAAS,GAAG,QAAQ,CAAC;gBACzB,GAAG,CAAC,QAAQ,CAAC,KAAK,GAAG,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBAC5E,GAAG,CAAC,QAAQ,CAAC,KAAK,GAAG,CAAC,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC;aACrF;SACJ;QAED,KAAmB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ,EAAE;YAAxB,IAAI,MAAM;YAEX,GAAG,CAAC,SAAS,EAAE,CAAC;YAChB,GAAG,CAAC,WAAW,GAAG,OAAO,CAAC;YAC1B,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,MAAM,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAC7C,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,MAAM,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAC/E,GAAG,CAAC,SAAS,EAAE,CAAC;YAChB,GAAG,CAAC,MAAM,EAAE,CAAC;SAChB;KACJ;IACD,GAAG,CAAC,OAAO,EAAE,CAAC;AAClB,CAAC;AAED,IAAI,UAAU,GAAG,KAAK,CAAC;AACvB,IAAI,MAAM,GAAG,CAAC,CAAC;AACf,IAAM,QAAQ,GAAG,UAAC,SAAiB;IAC/B,IAAI,UAAU,EAAE;QACZ,OAAO;KACV;IAED,IAAI,OAAO,GAAG,CAAC,SAAS,GAAG,MAAM,CAAC,GAAG,IAAI,CAAC;IAC1C,IAAI,OAAO,GAAG,EAAE,EAAE;QACd,OAAO,GAAG,IAAI,CAAC;KAClB;IAED,MAAM,CAAC,OAAO,CAAC,CAAC;IAChB,IAAI,CAAC,OAAO,CAAC,CAAC;IAEd,MAAM,GAAG,SAAS,CAAC;IACnB,qBAAqB,CAAC,QAAQ,CAAC,CAAC;AACpC,CAAC;AAED,QAAQ,CAAC,IAAI,CAAC,CAAC;AAEf,QAAQ,CAAC,gBAAgB,CAAC,SAAS,EAAE,UAAC,EAAE;IACpC,IAAI,EAAE,CAAC,IAAI,KAAK,MAAM,EAAE;QACpB,UAAU,GAAG,IAAI,CAAC;QAClB,MAAM,CAAC,IAAI,CAAC,CAAC;QACb,IAAI,CAAC,IAAI,CAAC,CAAC;KACd;IACD,IAAI,EAAE,CAAC,IAAI,KAAK,MAAM,EAAE;QACpB,UAAU,GAAG,KAAK,CAAC;QACnB,MAAM,GAAG,CAAC,CAAC;QACX,QAAQ,CAAC,IAAI,CAAC,CAAC;KAClB;IAED,IAAI,EAAE,CAAC,IAAI,KAAK,MAAM,EAAE;QACpB,QAAQ,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,EAAE,IAAI,eAAM,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;QACnE,QAAQ,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,EAAE,IAAI,eAAM,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;KACrE;IAED,IAAI,EAAE,CAAC,IAAI,KAAK,MAAM,EAAE;QACpB,QAAQ,CAAC,IAAI,CAAC,IAAI,eAAM,CAAC,EAAE,EAAE,IAAI,eAAM,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;KAClE;AACL,CAAC,CAAC","file":"main.js","sourcesContent":["import { Collider } from \"./collider\";\r\nimport { Contact } from \"./contact\";\r\nimport { Line } from \"./line\";\r\nimport { Motion, Transform } from \"./transform\";\r\nimport { Vector } from \"./vector\";\r\n\r\nexport class Circle extends Collider {\r\n    constructor(public radius: number, pos: Vector) {\r\n        super();\r\n        this.xf.pos = pos;\r\n        this.mass = radius;\r\n    }\r\n\r\n    get inverseMass() {\r\n        return this.static ? 0 : 1 / this.mass;\r\n    }\r\n\r\n    get inertia() {\r\n        return (this.mass * this.radius * this.radius) / 2;\r\n    }\r\n\r\n    get inverseInertia() {\r\n        return this.static ? 0 : 1 / this.inertia;\r\n    }\r\n\r\n    /**\r\n     * Returns a contact in the direction from `this` -> `other`\r\n     * @param other \r\n     * @returns \r\n     */\r\n    collide(other: Circle | Line, contact?: Contact): Contact | null {\r\n        if (other instanceof Circle) {\r\n            const combinedRadius = other.radius + this.radius;\r\n            const distance = other.xf.pos.distance(this.xf.pos);\r\n            if (distance < combinedRadius) {\r\n                const separation = combinedRadius - distance;\r\n                // normal points from A -> B\r\n                const direction = other.xf.pos.sub(this.xf.pos);\r\n                const normal = direction.normalize();\r\n                const tangent = normal.perpendicular();\r\n                const point = this.xf.pos.add(normal.scale(this.radius));\r\n                return new Contact(this, other, normal, tangent, [point]);\r\n            }\r\n            return null;\r\n        }\r\n\r\n        if (other instanceof Line) {\r\n            // flip so this -> other\r\n            const c = other.collide(this, contact) ?? null;\r\n            return c;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Apply impulse at a point\r\n     * @param point \r\n     * @param impulse \r\n     * @returns \r\n     */\r\n    applyImpulse(point: Vector, impulse: Vector) {\r\n        if (this.static) {\r\n            return;\r\n        }\r\n\r\n        const distanceFromCenter = point.sub(this.xf.pos);\r\n\r\n        this.m.vel = this.m.vel.add(impulse.scale(this.inverseMass));\r\n        this.m.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);\r\n    }\r\n}","import { Contact } from \"./contact\";\r\nimport { assert } from \"./math\";\r\nimport { Motion, Transform } from \"./transform\";\r\nimport { Vector } from \"./vector\";\r\n\r\nexport abstract class Collider {\r\n    private static _ID = 0;\r\n    public id = Collider._ID++;\r\n    public static = false;\r\n    public mass = 1;\r\n    \r\n    public bounciness = 0.1;\r\n    public friction = .99;\r\n    public xf = new Transform();\r\n    public m = new Motion();\r\n\r\n    get inverseMass() {\r\n        return this.static ? 0 : 1 / this.mass;\r\n    }\r\n\r\n    get inertia() {\r\n        return this.mass;\r\n    }\r\n\r\n    get inverseInertia() {\r\n        return this.static ? 0 : 1 / this.inertia;\r\n    }\r\n\r\n    /**\r\n     * Apply impulse at a point\r\n     * @param point \r\n     * @param impulse \r\n     * @returns \r\n     */\r\n    applyImpulse(point: Vector, impulse: Vector) {\r\n        if (this.static) {\r\n            return;\r\n        }\r\n\r\n        const distanceFromCenter = point.sub(this.xf.pos);\r\n\r\n        this.m.vel = this.m.vel.add(impulse.scale(this.inverseMass));\r\n        this.m.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);\r\n    }\r\n\r\n    applyLinearImpulse(impulse: Vector) {\r\n        if (this.static) {\r\n            return;\r\n        }\r\n\r\n        this.m.vel = this.m.vel.add(impulse.scale(this.inverseMass));\r\n    }\r\n\r\n    applyAngularImpulse(point: Vector, impulse: Vector) {\r\n        if (this.static) {\r\n            return;\r\n        }\r\n\r\n        const distanceFromCenter = point.sub(this.xf.pos);\r\n\r\n        this.m.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);\r\n    }\r\n\r\n    abstract collide(collider: Collider, contact?: Contact): Contact | null ;\r\n}","import { Circle } from \"./circle\";\r\nimport { Collider } from \"./collider\";\r\nimport { Line } from \"./line\";\r\nimport { assert } from \"./math\";\r\nimport { cross, Vector } from \"./vector\";\r\n\r\n/**\r\n * Holds information about contact points, meant to be reused over multiple frames of contact\r\n */\r\nexport class ContactPoint {\r\n\r\n    constructor(public point: Vector, public contact: Contact) {}\r\n\r\n    public getRelativeVelocity() {\r\n        const bodyA = this.contact.bodyA;\r\n        const bodyB = this.contact.bodyB;\r\n        // Relative velocity in linear terms\r\n        // Angular to linear velocity formula -> omega = velocity/radius so omega x radius = velocity\r\n        const vel = bodyB.m.vel.add(cross(bodyB.m.angularVelocity, this.bToContact)).sub(\r\n               bodyA.m.vel.sub(cross(bodyA.m.angularVelocity, this.aToContact)));\r\n\r\n        return vel;\r\n    }\r\n\r\n    /**\r\n     * Impulse accumulated over time in normal direction\r\n     */\r\n    public normalImpulse: number = 0;\r\n\r\n    /**\r\n     * Impulse accumulated over time in the tangent direction\r\n     */\r\n    public tangentImpulse: number = 0;\r\n\r\n    /**\r\n     * Effective mass seen in the normal direction\r\n     */\r\n    public normalMass: number = 0;\r\n    \r\n    /**\r\n     * Effective mass seen in the tangent direction\r\n     */\r\n    public tangentMass: number = 0;\r\n\r\n    /** \r\n     * Direction from center of mass of bodyA to contact point\r\n     */\r\n    public aToContact: Vector = new Vector(0, 0);\r\n\r\n    /** \r\n     * Direction from center of mass of bodyB to contact point\r\n     */\r\n    public bToContact: Vector = new Vector(0, 0);\r\n}\r\n\r\n/**\r\n * Represents contact between two rigid bodies\r\n * \r\n * Meant to be re-used over multiple frames\r\n */\r\nexport class Contact {\r\n\r\n    /**\r\n     * The unique id between 2 bodies\r\n     */\r\n    public get id() {\r\n        return Contact.GetId(this.bodyA, this.bodyB);\r\n    }\r\n\r\n    /**\r\n     * Get the id of 2 bodies\r\n     * @param bodyA \r\n     * @param bodyB \r\n     * @returns \r\n     */\r\n    public static GetId(bodyA: Collider, bodyB: Collider) {\r\n        if (bodyA.id < bodyB.id) {\r\n            return `${bodyA.id}+${bodyB.id}`;\r\n        } else {\r\n            return `${bodyB.id}+${bodyA.id}`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the separation in this contact (negative)\r\n     * @returns \r\n     */\r\n    public getSeparation() {\r\n        if (this.bodyA instanceof Circle && this.bodyB instanceof Circle) {\r\n            const combinedRadius = this.bodyA.radius + this.bodyB.radius;\r\n            const distance = this.bodyA.xf.pos.distance(this.bodyB.xf.pos);\r\n            const separation = combinedRadius - distance;\r\n            return -separation;\r\n        }\r\n\r\n        if (this.bodyA instanceof Circle && this.bodyB instanceof Line) {\r\n            return this.bodyB.getSeparation(this.bodyA);\r\n        }\r\n\r\n        if (this.bodyA instanceof Line && this.bodyB instanceof Circle) {\r\n            return this.bodyA.getSeparation(this.bodyB);\r\n        }\r\n\r\n        return 0\r\n    }\r\n\r\n    constructor(\r\n        public bodyA: Collider,\r\n        public bodyB: Collider,\r\n        public normal: Vector,\r\n        public tangent: Vector,\r\n        public points: Vector[] = []\r\n    ) {}\r\n}","import { Circle } from \"./circle\";\r\nimport { Collider } from \"./collider\";\r\nimport { Contact } from \"./contact\";\r\nimport { assert } from \"./math\";\r\nimport { Vector } from \"./vector\";\r\n\r\nexport class Line extends Collider {\r\n    static = true;\r\n    constructor(public begin: Vector, public end: Vector) {\r\n        super();\r\n        this.xf.pos = begin.add(end).scale(.5);\r\n    }\r\n\r\n    getSeparation(other: Circle) {\r\n        // center of the circle\r\n        const cc = other.xf.pos;\r\n        // vector in the direction of the edge\r\n        const e = this.end.sub(this.begin);\r\n        // amount of overlap with the circle's center along the edge direction\r\n        const u = e.dot(this.end.sub(cc));\r\n        const v = e.dot(cc.sub(this.begin));\r\n\r\n        const den = e.dot(e);\r\n        const pointOnEdge = this.begin\r\n            .scale(u)\r\n            .add(this.end.scale(v))\r\n            .scale(1 / den);\r\n        const d = cc.sub(pointOnEdge);\r\n\r\n        const dd = d.dot(d);\r\n\r\n        const sep = -Math.abs(other.radius - Math.sqrt(dd));\r\n        \r\n        return sep;\r\n    }\r\n    \r\n    collide(other: Circle | Line, contact?: Contact): Contact | null {\r\n        if (other instanceof Circle) {\r\n\r\n            // center of the circle\r\n            const cc = other.xf.pos;\r\n            // vector in the direction of the edge\r\n            const e = this.end.sub(this.begin);\r\n            \r\n            // amount of overlap with the circle's center along the edge direction\r\n            const u = e.dot(this.end.sub(cc));\r\n            const v = e.dot(cc.sub(this.begin));\r\n            \r\n            // Potential region A collision (circle is on the left side of the edge, before the beginning)\r\n            if (v <= 0) {\r\n                const da = this.begin.sub(cc);\r\n                const dda = da.dot(da); // quick and dirty way of calc'n distance in r^2 terms saves some sqrts\r\n                // save some sqrts\r\n                if (dda > other.radius * other.radius) {\r\n                    return null; // no collision\r\n                }\r\n                // RETURN CONTACT\r\n                let separation = da.normalize().scale(other.radius - Math.sqrt(dda));\r\n                let normal = da.normalize();\r\n                return new Contact(other, this, normal, normal.perpendicular(), [this.begin]);\r\n            }\r\n            \r\n            // Potential region B collision (circle is on the right side of the edge, after the end)\r\n            if (u <= 0) {\r\n                const db = this.end.sub(cc);\r\n                const ddb = db.dot(db);\r\n                if (ddb > other.radius * other.radius) {\r\n                    return null;\r\n                }\r\n                // RETURN CONTACT\r\n                let separation = db.normalize().scale(other.radius - Math.sqrt(ddb));\r\n                let normal = db.normalize();\r\n                return new Contact(other, this, normal, normal.perpendicular(), [this.end]);\r\n            }\r\n\r\n            // Otherwise potential region AB collision (circle is in the middle of the edge between the beginning and end)\r\n            const den = e.dot(e);\r\n            const pointOnEdge = this.begin\r\n                .scale(u)\r\n                .add(this.end.scale(v))\r\n                .scale(1 / den);\r\n            const d = cc.sub(pointOnEdge);\r\n\r\n            const dd = d.dot(d);\r\n            if (dd > other.radius * other.radius) {\r\n                return null; // no collision\r\n            }\r\n\r\n            let n = e.perpendicular();\r\n            // flip correct direction\r\n            if (n.dot(cc.sub(this.begin)) < 0) {\r\n                n.x = -n.x;\r\n                n.y = -n.y;\r\n            }\r\n\r\n            n = n.normalize();\r\n\r\n            const mvt = n.scale(Math.abs(other.radius - Math.sqrt(dd)));\r\n\r\n            // RETURN CONTACT\r\n            return new Contact(this, other, n, n.perpendicular(), [pointOnEdge]);\r\n        }\r\n\r\n        return null;\r\n    }\r\n}","export const clamp = (val: number, min: number, max: number) => {\r\n    return Math.max(Math.min(val, max), min);\r\n}\r\n\r\nexport const assert = (shouldBeTrue: boolean, message: string) => {\r\n    if (!shouldBeTrue) {\r\n        throw new Error(message)\r\n    }\r\n}\r\n\r\nexport const shuffle = (list: any[]) => {\r\n  // knuth shuffle\r\n  let currentIndex = list.length;\r\n  let randomIndex = 0;\r\n  let tmp = null;\r\n  while (currentIndex > 0) {\r\n      // Pick a remaining element...\r\n    randomIndex = Math.floor(Math.random() * currentIndex);\r\n    currentIndex--;\r\n\r\n    // And swap it with the current element.\r\n    tmp = list[currentIndex];\r\n    list[currentIndex] = list[randomIndex];\r\n    list[randomIndex] = tmp;\r\n  }\r\n  return list;\r\n}","import { Contact, ContactPoint } from \"./contact\";\r\nimport { assert, clamp } from \"./math\";\r\n\r\nexport class Solver {\r\n    lastFrameContacts: Map<string, Contact> = new Map();\r\n\r\n    // map contact id to contact points\r\n    idToContactPoints: Map<string, ContactPoint[]> = new Map();\r\n\r\n    getContactPoints(id: string) {\r\n        return this.idToContactPoints.get(id) ?? [];\r\n    }\r\n\r\n    preSolve(contacts: Contact[]) {\r\n        // Keep track of contacts that done\r\n        let finishedContactIds = Array.from(this.idToContactPoints.keys());\r\n        for (let contact of contacts) {\r\n            // Remove all current contacts that are not done\r\n            let index = finishedContactIds.indexOf(contact.id);\r\n            if (index > -1) {\r\n                finishedContactIds.splice(index, 1);\r\n            }\r\n            let contactPoints = this.idToContactPoints.get(contact.id) ?? [];\r\n            \r\n            let pointIndex = 0;\r\n            for (let point of contact.points) {\r\n                const bodyA = contact.bodyA;\r\n                const bodyB = contact.bodyB;\r\n                const normal = contact.normal;\r\n                const tangent = contact.tangent;\r\n\r\n                const aToContact = point.sub(bodyA.xf.pos);\r\n                const bToContact = point.sub(bodyB.xf.pos);\r\n    \r\n                const aToContactNormal = aToContact.cross(normal);\r\n                const bToContactNormal = bToContact.cross(normal);\r\n\r\n                const normalMass = bodyA.inverseMass + bodyB.inverseMass + \r\n                                bodyA.inverseInertia * aToContactNormal * aToContactNormal +\r\n                                bodyB.inverseInertia * bToContactNormal * bToContactNormal;\r\n\r\n                const aToContactTangent = aToContact.cross(tangent);\r\n                const bToContactTangent = bToContact.cross(tangent);\r\n    \r\n                const tangentMass = bodyA.inverseMass + bodyB.inverseMass +\r\n                                bodyA.inverseInertia * aToContactTangent * aToContactTangent +\r\n                                bodyB.inverseInertia * bToContactTangent * bToContactTangent;\r\n\r\n                // Preserve normal/tangent impulse by re-using the contact point if it's close\r\n                if (contactPoints[pointIndex] && contactPoints[pointIndex]?.point?.squareDistance(point) < 4) {\r\n                    contactPoints[pointIndex].point = point;\r\n                } else {\r\n                    // new contact if its' not close or doesn't exist\r\n                    contactPoints[pointIndex] = new ContactPoint(point, contact);\r\n                }\r\n\r\n                // Update contact point calculations\r\n                contactPoints[pointIndex].aToContact = aToContact;\r\n                contactPoints[pointIndex].bToContact = bToContact;\r\n                contactPoints[pointIndex].normalMass = normalMass;\r\n                contactPoints[pointIndex].tangentMass = tangentMass;\r\n\r\n                pointIndex++\r\n            }\r\n            this.idToContactPoints.set(contact.id, contactPoints);\r\n        }\r\n\r\n        // Clean up any contacts that did not occur last frame\r\n        for (const id of finishedContactIds) {\r\n            this.idToContactPoints.delete(id);\r\n        }\r\n    }\r\n\r\n    postSolve(contacts: Contact[]) {\r\n        // Store contacts\r\n        this.lastFrameContacts.clear();\r\n        for (const c of contacts) {\r\n            this.lastFrameContacts.set(c.id, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Warm up body's based on previous frame contact points\r\n     * @param contacts \r\n     */\r\n    warmStart(contacts: Contact[]) {\r\n        for (let contact of contacts) {\r\n            let contactPoints = this.idToContactPoints.get(contact.id) ?? [];\r\n            for (let point of contactPoints) {\r\n\r\n                const normalImpulse = contact.normal.scale(point.normalImpulse);\r\n                // Scaling back the tangent impulse seems to increase stack stability?\r\n                const tangentImpulse = contact.tangent.scale(point.tangentImpulse).scale(.2);\r\n                const impulse = normalImpulse.add(tangentImpulse);\r\n                // contact.bodyA.applyImpulse(point.point, impulse.negate());\r\n                // contact.bodyB.applyImpulse(point.point, impulse);\r\n\r\n                contact.bodyA.applyLinearImpulse(normalImpulse.negate());\r\n                contact.bodyA.applyAngularImpulse(point.point, tangentImpulse.negate());\r\n\r\n                contact.bodyB.applyLinearImpulse(normalImpulse);\r\n                contact.bodyB.applyAngularImpulse(point.point, tangentImpulse);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Iteratively solve the position overlap constraint\r\n     * @param contacts \r\n     */\r\n    solvePosition(contacts: Contact[]) {\r\n        for (let contact of contacts) {\r\n            let contactPoints = this.idToContactPoints.get(contact.id) ?? [];\r\n            for (let point of contactPoints) {\r\n                const bodyA = contact.bodyA;\r\n                const bodyB = contact.bodyB;\r\n                const normal = contact.normal;\r\n                const separation = contact.getSeparation();\r\n\r\n                const steeringConstant = 0.2\r\n                const maxCorrection = -5;\r\n                const slop = 1;\r\n                // Clamp to avoid over-correction\r\n                // Remember that we are shooting for 0 overlap in the end\r\n                const steeringForce = clamp(steeringConstant * (separation + slop), maxCorrection, 0);\r\n                const impulse = normal.scale(-steeringForce / point.normalMass);\r\n\r\n                \r\n                // This is a pseudo impulse, meaning we aren't doing a real impulse calculation\r\n                // We adjust position and rotation instead of doing the velocity\r\n                if (!bodyA.static) {\r\n                    bodyA.xf.pos = bodyA.xf.pos.add(impulse.negate().scale(bodyA.inverseMass));\r\n                    bodyA.xf.rotation -= point.aToContact.cross(impulse) * bodyA.inverseInertia;\r\n                }\r\n\r\n                if (!bodyB.static) {\r\n                    bodyB.xf.pos = bodyB.xf.pos.add(impulse.scale(bodyB.inverseMass));\r\n                    bodyB.xf.rotation += point.bToContact.cross(impulse) * bodyB.inverseInertia;\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    solveVelocity(contacts: Contact[]) {\r\n        for (let contact of contacts) {\r\n            const bodyA = contact.bodyA;\r\n            const bodyB = contact.bodyB;\r\n\r\n            const restitution = bodyA.bounciness * bodyB.bounciness;\r\n            const friction = Math.min(bodyA.friction, bodyB.friction);\r\n            let contactPoints = this.idToContactPoints.get(contact.id) ?? [];\r\n\r\n            for (let point of contactPoints) {\r\n                const relativeVelocity = point.getRelativeVelocity();\r\n\r\n                // Negate velocity in tangent direction to simulate friction\r\n                const tangentVelocity = -relativeVelocity.dot(contact.tangent);\r\n                let impulseDelta = tangentVelocity / point.tangentMass;\r\n\r\n                // Clamping based in Erin Catto's GDC 2006 talk\r\n                // Correct clamping https://github.com/erincatto/box2d-lite/blob/master/docs/GDC2006_Catto_Erin_PhysicsTutorial.pdf\r\n                // Accumulated fiction impulse is always between -uMaxFriction < dT < uMaxFriction\r\n                // But deltas can vary\r\n                const maxFriction = friction * point.normalImpulse;\r\n                const newImpulse = clamp(point.tangentImpulse + impulseDelta, -maxFriction, maxFriction);\r\n                impulseDelta = newImpulse - point.tangentImpulse;\r\n                point.tangentImpulse = newImpulse;\r\n\r\n                const impulse = contact.tangent.scale(impulseDelta);\r\n                bodyA.applyImpulse(point.point, impulse.negate());\r\n                bodyB.applyImpulse(point.point, impulse);\r\n            }\r\n\r\n            for (let point of contactPoints) {\r\n                // Need to recalc relative velocity because the previous step could have changed vel\r\n                const relativeVelocity = point.getRelativeVelocity();\r\n\r\n                // Compute impulse in normal direction\r\n                const normalVelocity = relativeVelocity.dot(contact.normal);\r\n                // See https://en.wikipedia.org/wiki/Collision_response\r\n                let impulseDelta = (-(1 + restitution) * normalVelocity) / point.normalMass;\r\n\r\n                // Clamping based in Erin Catto's GDC 2014 talk\r\n                // Accumulated impulse stored in the contact is always positive (dV > 0)\r\n                // But deltas can be negative\r\n                const newImpulse = Math.max(point.normalImpulse + impulseDelta, 0);\r\n                impulseDelta = newImpulse - point.normalImpulse;\r\n                point.normalImpulse = newImpulse;\r\n\r\n                const impulse = contact.normal.scale(impulseDelta);\r\n                bodyA.applyImpulse(point.point, impulse.negate());\r\n                bodyB.applyImpulse(point.point, impulse);\r\n            }\r\n        }\r\n    }\r\n}","import { Vector } from \"./vector\";\r\n\r\nexport class Transform {\r\n    public pos: Vector = new Vector(0, 0);\r\n    public rotation: number = 0;\r\n}\r\n\r\nexport class Motion {\r\n    public vel: Vector = new Vector(0, 0);\r\n    public acc: Vector = new Vector(0, 0);\r\n\r\n    public angularVelocity: number = 0;\r\n}","export class Vector {\r\n    constructor(public x: number, public y: number) {}\r\n    distance(other: Vector) {\r\n        const dx = this.x - other.x;\r\n        const dy = this.y - other.y;\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n\r\n    squareDistance(other: Vector) {\r\n        const dx = this.x - other.x;\r\n        const dy = this.y - other.y;\r\n        return dx * dx + dy * dy;\r\n    }\r\n\r\n    normalize(): Vector {\r\n        const d = this.distance(new Vector(0, 0));\r\n        return new Vector(this.x / d, this.y / d);\r\n    }\r\n\r\n    size(): number {\r\n        return this.distance(new Vector(0, 0));\r\n    }\r\n\r\n    scale(val: number): Vector {\r\n        return new Vector(this.x * val, this.y * val);\r\n    }\r\n\r\n    negate(): Vector {\r\n        return this.scale(-1);\r\n    }\r\n\r\n    /**\r\n     * Returns the perpendicular vector to this one\r\n     */\r\n    perpendicular(): Vector {\r\n        return new Vector(this.y, -this.x);\r\n    }\r\n\r\n    /**\r\n     * Returns the normal vector to this one, same as the perpendicular of length 1\r\n     */\r\n    normal(): Vector {\r\n        return this.perpendicular().normalize();\r\n    }\r\n\r\n    dot(other: Vector): number {\r\n        return this.x * other.x + this.y * other.y;\r\n    }\r\n\r\n    /**\r\n     * Performs a 2D cross product with scalar. 2D cross products with a scalar return a vector.\r\n     * @param v  The scalar to cross\r\n     */\r\n    cross(v: number): Vector;\r\n    /**\r\n     * Performs a 2D cross product with another vector. 2D cross products return a scalar value not a vector.\r\n     * @param v  The vector to cross\r\n     */\r\n    cross(v: Vector): number;\r\n    cross(v: number | Vector): number | Vector {\r\n        if (v instanceof Vector) {\r\n            return this.x * v.y - this.y * v.x;\r\n        } else {\r\n            return new Vector(v * this.y, -v * this.x);\r\n        }\r\n    }\r\n\r\n    add(other: Vector): Vector {\r\n        return new Vector(this.x + other.x, this.y + other.y);\r\n    }\r\n\r\n    /**\r\n     * Creates a vector in the direcion of `other` -> `this`\r\n     * @param other \r\n     * @returns \r\n     */\r\n    sub(other: Vector): Vector {\r\n        return new Vector(this.x - other.x, this.y - other.y);\r\n    }\r\n}\r\n\r\nexport const cross = (num: number, vec: Vector) => {\r\n    return new Vector(-num * vec.y, num * vec.x)\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { Circle } from \"./circle\";\r\nimport { Contact } from \"./contact\";\r\nimport { Line } from \"./line\";\r\nimport { assert, clamp, shuffle } from \"./math\";\r\nimport { Solver } from \"./solver\";\r\nimport { Vector } from \"./vector\";\r\n\r\nconst canvas = document.createElement('canvas');\r\ncanvas.width = 800;\r\ncanvas.height = 600;\r\nconst ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\r\ndocument.body.appendChild(canvas);\r\n\r\n\r\nconst gui = new dat.GUI({ name: 'Iterative Solver' });\r\nconst flags: Record<string, number | boolean> = {\r\n    \"Debug\": true,\r\n    \"Warming\": true,\r\n    \"Position Iterations\": 2,\r\n    \"Velocity Iterations\": 8,\r\n    \"Gravity Value\": 400,\r\n    \"Gravity\": false\r\n}\r\nfor (let key in flags) {\r\n    if (typeof flags[key] === 'number') {\r\n        gui.add(flags, key, 0, 20, 1);\r\n    }\r\n    if (typeof flags[key] === 'boolean') {\r\n        gui.add(flags, key);\r\n    }\r\n}\r\n\r\nconst entities = [\r\n    new Line(new Vector(50, 550), new Vector(750, 550)),\r\n    new Line(new Vector(100, 100), new Vector(300, 650)),\r\n    new Line(new Vector(500, 650), new Vector(700, 100)),\r\n    new Circle(40, new Vector(canvas.width / 2, 400)),\r\n    new Circle(40, new Vector(canvas.width / 2, 300)),\r\n    // new Circle(40, new Vector(canvas.width / 2, 200)),\r\n    // new Circle(40, new Vector(canvas.width / 2, 100)),\r\n    // new Circle(40, new Vector(canvas.width / 2, 0)),\r\n    // new Circle(40, new Vector(canvas.width / 2, -100)),\r\n    // new Circle(40, new Vector(canvas.width / 2, -200)),\r\n];\r\n(window as any).entities = entities;\r\n\r\nlet solver = new Solver();\r\nlet contacts: Contact[] = [];\r\nconst update = (elapsed: number) => {\r\n    let acc = new Vector(0, 0);\r\n    if (flags['Gravity']) {\r\n        acc = new Vector(0, flags['Gravity Value'] as number);\r\n    }\r\n\r\n    // Integrate motion\r\n    for (let circle of entities) {\r\n        if (!circle.static) {\r\n            circle.m.vel = circle.m.vel.add(acc.scale(elapsed));\r\n            circle.m.angularVelocity = clamp(circle.m.angularVelocity, -Math.PI, Math.PI);\r\n        }\r\n    }\r\n\r\n    // Naive descrete collision detection (broadphase + narrowphase)\r\n    // We re-use contacts from the previous frame if they exist\r\n    contacts = []\r\n    for (let i = 0; i < entities.length; i++) {\r\n        for (let j = i + 1; j < entities.length; j++) {\r\n            let circleA = entities[i];\r\n            let circleB = entities[j];\r\n            let contact = circleA.collide(circleB);\r\n            if (contact) {\r\n                contacts.push(contact);\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n    // Initialize contact information\r\n    solver.preSolve(contacts);\r\n    \r\n    // Warm start impulses for velocity constraint\r\n    // This helps with simulation coherence by reusing work from previous frames\r\n    // Practically this will cancel gravity on big stacks\r\n    if (flags[\"Warming\"]) {\r\n        solver.warmStart(contacts);\r\n    } else {\r\n        for (let contact of contacts) {\r\n            let contactPoints = solver.getContactPoints(contact.id);\r\n            for (let point of contactPoints) {\r\n                point.normalImpulse = 0;\r\n                point.tangentImpulse = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    // The velocity constraint is that no contacts are moving relative to each other along the normal\r\n    // in other words relative velocity between contacts should approach 0 on the normal\r\n    for (let i = 0; i < flags['Velocity Iterations']; i++) {\r\n        solver.solveVelocity(contacts);\r\n    }\r\n\r\n    // Integrate positions\r\n    for (let circle of entities) {\r\n        if (!circle.static) {\r\n            circle.xf.pos = circle.xf.pos.add(circle.m.vel.scale(elapsed)).add(acc.scale(0.5 * elapsed * elapsed));\r\n            circle.xf.rotation += circle.m.angularVelocity * elapsed;\r\n            while (circle.xf.rotation > Math.PI * 2) {\r\n                circle.xf.rotation -= Math.PI * 2;\r\n            }\r\n            while (circle.xf.rotation < 0) {\r\n                circle.xf.rotation += Math.PI * 2;\r\n            }\r\n        }\r\n    }\r\n\r\n    // The constraint is separation should approach 0\r\n    for (let i = 0; i < flags['Position Iterations']; i++) {\r\n        solver.solvePosition(contacts);\r\n    }\r\n\r\n    solver.postSolve(contacts);\r\n}\r\n\r\n\r\nconst draw = (elapsed: number) => {\r\n    ctx.save();\r\n    ctx.fillStyle = 'black';\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n    for (let e of entities) {\r\n        if (e instanceof Circle) {\r\n            ctx.beginPath();\r\n            ctx.fillStyle = 'blue';\r\n            ctx.arc(e.xf.pos.x, e.xf.pos.y, e.radius, 0, Math.PI * 2);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n\r\n            if (flags[\"Debug\"]) {\r\n                ctx.fillStyle = 'yellow';\r\n                ctx.fillText('id: ' + e.id, e.xf.pos.x, e.xf.pos.y);\r\n            }\r\n\r\n            ctx.save();\r\n            ctx.translate(e.xf.pos.x, e.xf.pos.y);\r\n            ctx.rotate(e.xf.rotation);\r\n            ctx.beginPath()\r\n            ctx.strokeStyle = 'black';\r\n            ctx.moveTo(0, 0);\r\n            ctx.lineTo(0 + e.radius, 0);\r\n            ctx.closePath();\r\n            ctx.stroke();\r\n            ctx.restore();\r\n        }\r\n\r\n        if (e instanceof Line) {\r\n            ctx.save();\r\n            ctx.beginPath();\r\n            ctx.strokeStyle = 'green'\r\n            ctx.moveTo(e.begin.x, e.begin.y);\r\n            ctx.lineTo(e.end.x, e.end.y);\r\n            ctx.closePath();\r\n            ctx.stroke();\r\n            ctx.restore();\r\n\r\n            if (flags[\"Debug\"]) {\r\n                ctx.fillStyle = 'yellow';\r\n                ctx.fillText('id: ' + e.id, e.xf.pos.x, e.xf.pos.y);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (flags[\"Debug\"]) {\r\n        for (let contact of contacts) {\r\n            let contactPoints = solver.getContactPoints(contact.id);\r\n            for (let p of contactPoints) {\r\n                ctx.beginPath();\r\n                ctx.strokeStyle = 'yellow'\r\n                ctx.arc(p.point.x, p.point.y, 5, 0, Math.PI * 2);\r\n                ctx.closePath();\r\n                ctx.stroke();\r\n\r\n                ctx.beginPath();\r\n                ctx.strokeStyle = 'red'\r\n                ctx.moveTo(p.point.x, p.point.y);\r\n                ctx.lineTo(p.point.x + contact.normal.x * 10, p.point.y + contact.normal.y * 10);\r\n                ctx.closePath();\r\n                ctx.stroke();\r\n\r\n                ctx.fillStyle = 'yellow';\r\n                ctx.fillText('N- ' + p.normalImpulse.toFixed(1), p.point.x + 10, p.point.y);\r\n                ctx.fillText('T- ' + p.tangentImpulse.toFixed(1), p.point.x + 10, p.point.y + 10);\r\n            }\r\n        }\r\n\r\n        for (let circle of entities) {\r\n            \r\n            ctx.beginPath();\r\n            ctx.strokeStyle = 'green';\r\n            ctx.moveTo(circle.xf.pos.x, circle.xf.pos.y);\r\n            ctx.lineTo(circle.xf.pos.x + circle.m.vel.x, circle.xf.pos.y + circle.m.vel.y);\r\n            ctx.closePath();\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    ctx.restore();\r\n}\r\n\r\nlet singleStep = false;\r\nlet lastMs = 0;\r\nconst mainloop = (currentMs: number) => {\r\n    if (singleStep) {\r\n        return;\r\n    }\r\n\r\n    let seconds = (currentMs - lastMs) / 1000;\r\n    if (seconds > .1) {\r\n        seconds = .016;\r\n    }\r\n\r\n    update(seconds);\r\n    draw(seconds);\r\n\r\n    lastMs = currentMs;\r\n    requestAnimationFrame(mainloop);\r\n}\r\n\r\nmainloop(.016);\r\n\r\ndocument.addEventListener('keydown', (ev) => {\r\n    if (ev.code === 'KeyS') {\r\n        singleStep = true;\r\n        update(.016);\r\n        draw(.016);\r\n    }\r\n    if (ev.code === 'KeyT') {\r\n        singleStep = false;\r\n        lastMs = 0;\r\n        mainloop(.016);\r\n    }\r\n\r\n    if (ev.code === 'KeyI') {\r\n        entities[3].applyImpulse(entities[3].xf.pos, new Vector(0, -5500));\r\n        entities[4].applyImpulse(entities[4].xf.pos, new Vector(0, 5500));\r\n    }\r\n\r\n    if (ev.code === 'KeyB') {\r\n        entities.push(new Circle(40, new Vector(canvas.width / 2, 0)));\r\n    }\r\n})\r\n"],"sourceRoot":""}